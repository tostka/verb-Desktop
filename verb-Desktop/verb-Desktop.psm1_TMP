# verb-desktop.psm1


  <#
  .SYNOPSIS
  verb-Desktop - Powershell Desktop generic functions module
  .NOTES
  Version     : 4.2.0.0
  Author      : Todd Kadrie
  Website     :	https://www.toddomation.com
  Twitter     :	@tostka
  CreatedDate : 3/1/2020
  FileName    : verb-Desktop.psm1
  License     : MIT
  Copyright   : (c) 3/1/2020 Todd Kadrie
  Github      : https://github.com/tostka
  AddedCredit : REFERENCE
  AddedWebsite:	REFERENCEURL
  AddedTwitter:	@HANDLE / http://twitter.com/HANDLE
  REVISIONS
  * 3/1/2020 - 1.0.0.0
  .DESCRIPTION
  verb-Desktop - Powershell Desktop generic functions module
  .PARAMETER  PARAMNAME
  PARAMDESC
  .PARAMETER  Mbx
  Mailbox identifier [samaccountname,name,emailaddr,alias]
  .PARAMETER  Computer
  Computer Name [-ComputerName server]
  .PARAMETER  ServerFqdn
  Server Fqdn (24-25char) [-serverFqdn lynms650.global.ad.toro.com)] 
  .PARAMETER  Server
  Server NBname (8-9chars) [-server lynms650)]
  .PARAMETER  SiteName
  Specify Site to analyze [-SiteName (USEA|GBMK|AUSYD]
  .PARAMETER  Ticket
  Ticket # [-Ticket nnnnn]
  .PARAMETER  Path
  Path [-path c:\path-to\]
  .PARAMETER  File
  File [-file c:\path-to\file.ext]
  .PARAMETER  String
  2-30 char string [-string 'word']
  .PARAMETER  Credential
  Credential (PSCredential obj) [-credential ]
  .PARAMETER  Logonly
  Run a Test no-change pass, and log results [-Logonly]
  .PARAMETER  FORCEALLPINS
  Reset All PINs (boolean) [-FORCEALLPINS:True]
  .PARAMETER Whatif
  Parameter to run a Test no-change pass, and log results [-Whatif switch]
  .PARAMETER ShowProgress
  Parameter to display progress meter [-ShowProgress switch]
  .PARAMETER ShowDebug
  Parameter to display Debugging messages [-ShowDebug switch]
  .INPUTS
  None
  .OUTPUTS
  None
  .EXAMPLE
  .EXAMPLE
  .LINK
  https://github.com/tostka/verb-Desktop
  #>


    $script:ModuleRoot = $PSScriptRoot ;
    $script:ModuleVersion = (Import-PowerShellDataFile -Path (get-childitem $script:moduleroot\*.psd1).fullname).moduleversion ;
    $runningInVsCode = $env:TERM_PROGRAM -eq 'vscode' ;

#*======v FUNCTIONS v======




#*------v .....ps1 v------
function .... { ...; .. }

#*------^ .....ps1 ^------


#*------v ....ps1 v------
function ... { ..; .. }

#*------^ ....ps1 ^------


#*------v ...ps1 v------
function .. { Set-Location .. }

#*------^ ...ps1 ^------


#*------v ~.ps1 v------
function ~ { Push-Location (Get-PSProvider FileSystem).Home }

#*------^ ~.ps1 ^------


#*------v Clean-Desktop.ps1 v------
function Clean-Desktop {
        <#
        .SYNOPSIS
        Clean-Desktop - Purges all .lnk files from user profile desktop
        .NOTES
        Author: Todd Kadrie
        Website:	http://www.toddomation.com
        Twitter:	@tostka, http://twitter.com/tostka
        REVISIONS   :
        * 12:56 PM 9/18/2019 added a catch echo to try clean-desktop as SID, and label the attempt
        * 8:18 AM 8/1/2019 added OD4B redir & a bunch of logic to leave my normal .lnks in place, also added -whatif & -showdebug, for testing, and extra echos.
        * 10:46 PM 5/31/2019 init vers
        .DESCRIPTION
        Clean-Desktop.ps1 - Purges all .lnk files from user profile desktop
        .INPUTS
        None. Does not accepted piped input.
        .OUTPUTS
        Dumps info to console, and copies to clipboard
        .EXAMPLE
        Clean-Desktop ;
        .LINK
        http://www.toddomation.com
        #>
        Param(
            [Parameter(HelpMessage = "Whatif Flag  [-whatIf]")][switch] $whatIf,
            [Parameter(HelpMessage = "showDebug Flag  [-showDebug]")][switch] $showDebug
        ) ;
        $error.clear() ;
        TRY {
            $pDesktop = [Environment]::GetFolderPath('Desktop') ;
            $parkingDir = "$($env:USERPROFILE)\AppData\Roaming\Microsoft\Internet Explorer\Quick Launch\DesktopBU" ;
            if (-not(test-path $parkingDir)) {
                write-verbose -verbose:$true  "(creating missing:$($parkingDir))" ;
                mkdir $parkingDir ;
            } ;

            $lnkFiles = @() ; $movelinks = @() ;
            $lnkFiles = gci $env:USERPROFILE\Desktop\*lnk | select -exp fullname ;
            $lnkFiles += gci C:\Users\Public\Desktop\*lnk | select -exp fullname ;
            if ($pDesktop  ) {
                if ($showDebug) { write-host -foregroundcolor green "(detected OD4B)" };
                $lnkFiles += gci "$($pDesktop)\*lnk" | select -exp fullname ;
            } ;
            $lnkFiles = $lnkFiles | ? { $_ -notmatch '(\d{6}|ecco32\.exe|Kindle|Start\sMenu|BIG-IP|Chrome|Firefox|Microsoft\sEdge|PowerShell|cmd\.exe|Outlook|TeaTimer)' } ;
            foreach ($lnkFile in $lnkFiles) {
                if ($showDebug) { write-host "processing `$lnkfile:$($lnkfile)" } ;
                if ((gi (Get-Shortcut -path $lnkFile ).targetpath -ea 0).PSIsContainer) {
                }
                elseif ((get-shortcut $lnkFile).targetpath -match '.*(\.(txt|cmd)$)|(rundll32|Notepad2)\.exe$') {
                }
                elseif (!(get-shortcut $lnkFile).targetpath) {
                    # MS edge HAS NO TARGETPATH! - had to reexempt it on lnk name, this was still thowing 2 empty path errors
                }
                else {
                    if ($showDebug) { write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):adding $($lnkFile)" } ;
                    $movelinks += $lnkFile ;
                }
            } ;
            if ($movelinks) {
                write-verbose -verbose:$true  "(Clean-Desktop:moving $(($movelinks|measure).count) files from profile desktop to:$($parkingDir)...`n$(($move|out-string).trim()))" ;
                #move-Item -path $lnkFiles -Destination $parkingDir -Force -whatif:$($whatif);
                move-Item -path $movelinks -Destination $parkingDir -Force -whatif:$($whatif);
            } ;
        }
        CATCH {
            Write-Error "$(get-date -format 'HH:mm:ss'): Clean-Desktop:Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
            write-host -foregroundcolor yellow "(if perms, try SID: Clean-Desktop)";
            Exit ;
        } ;

    }

#*------^ Clean-Desktop.ps1 ^------


#*------v confirm-GoogleDriveRunning.ps1 v------
Function confirm-GoogleDriveRunning {

    <# 
    .SYNOPSIS
    confirm-GoogleDriveRunning - Confirm/Run Google Drive - Resolve Google Drive letter; test for drive letter present(running): start GD if drive not present (Resolve Google Drive .exe path from default installed Start Mnu .lnk) 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-11-11
    FileName    : confirm-GoogleDriveRunning.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-Desktop
    Tags        : GoogleDrive
    AddedCredit : mklement0
    AddedWebsite:	https://stackoverflow.com/users/45375/mklement0
    AddedTwitter:	
    REVISIONS   :
    # 11:14 AM 11/11/2022 my revisions: added [codewario](https://stackoverflow.com/users/584676/codewario)'s answer to M's question; added .exe resolution via default start mnu Google Drive.lnk expansion. Try catch, whatif, and now outputs boolean to pipeline, for testing 
    * 11:15 AM 9/1/21 mklement0's posted question code
    .DESCRIPTION
    confirm-GoogleDriveRunning - Confirm/Run Google Drive - Resolve Google Drive letter; test for drive letter present(running): start GD if drive not present (Resolve Google Drive .exe path from default installed Start Mnu .lnk) 
    
    Expanded version of mklement0's posted concept snippet from stackoverflow question:
    [powershell - Find the mapped google drive - Stack Overflow - stackoverflow.com/](https://stackoverflow.com/questions/69017164/find-the-mapped-google-drive)
    Added .exe resolution code; spliced in bender's answer to the original question. 
    
    .PARAMETER  Path
    Path to be overlayed over specified background
    .PARAMETER Whatif
    Whatif no-exec test
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    System.Boolean
    .EXAMPLE
    PS> if(confirm-GoogleDriveRunning -verbose -whatif){'y'} else { 'n'} ; 
    Confirm Gdrv running, with verbose and whatif 
    .LINK
    https://github.com/tostka/verb-Desktop
    #>
    [CmdletBinding()]
    #[Alias('')]
    Param(
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) ; 
    write-verbose "Attempt to Resolve Google Drive PSDrive (local drive vs mounted)" ; 
    Try {
        If (!($gdrvDrive = Get-PSDrive -PSProvider FileSystem | 
            Where-Object {$_.Description -eq 'Google Drive' })) {
            write-verbose "Resolve Google Drive .exe loc from the stock launch .lnk" ; 
            $gdrvLnk = "$env:ProgramData\Microsoft\Windows\Start Menu\Programs\Google Drive.lnk" ; 
            write-verbose "expand shortcut TargetPath" ; 
            $WScriptShell = New-Object -ComObject WScript.Shell ; 
            if (Test-Path $gdrvLnk) {
                $GdfsPath  = $WScriptShell.CreateShortcut((Resolve-Path $gdrvLnk)).targetpath ;
                if(!$whatif){
                    write-verbose "Start-Process resolved path:`n$($gdfsPath)`n(30s timeout)" ; 
                        Start-Process $GdfsPath | Wait-Process -Timeout 30 ;
                } else { 
                    write-host "-whatif: skipping run exeution of:`n$($GdfsPath)" ; 
                } ; 
            } else {
                $smsg = "Unable to resolve Google Drive.lnk to an exe path!`n$($gdrvLnk)" ; 
                write-warning $smsg ; throw $smsg ; 
            } ; 
        } else {
            write-verbose "Google drive present ($($gdrvDrive.Root):), returning `$true to pipeline" ; 
            $true | write-output ; 
        } ; 
    } Catch {
            $smsg = "Google Drive can't be mapped. Failed to load Gdrv: $($GdfsPath)"
             write-warning $smsg ; throw $smsg ; 
             $false | write-output ; 
    } 
    Finally {
        If (!(Get-PSDrive -PSProvider FileSystem | 
    Where-Object {$_.Description -eq 'Google Drive' })) {
            $smsg = "Google Drive can't be mapped. Failed to load Gdrv: $($GdfsPath)"
             write-warning $smsg ; throw $smsg ; 
             $false | write-output ; 
        } ;
    } ;
}

#*------^ confirm-GoogleDriveRunning.ps1 ^------


#*------v c-winsallk.ps1 v------
function c-winsallk {. C:\usr\work\ps\scripts\close-WinsAll.ps1 -kill  }

#*------^ c-winsallk.ps1 ^------


#*------v Define-MoveWindow.ps1 v------
function Define-MoveWindow {
    $signature = @'
[DllImport("user32.dll")]
public static extern bool MoveWindow(
IntPtr hWnd,
int X,
int Y,
int nWidth,
int nHeight,
bool bRepaint);
'@
    Add-Type -MemberDefinition $signature -Name MoveWindowUtil -Namespace MoveWindowUtil
}

#*------^ Define-MoveWindow.ps1 ^------


#*------v Disable-AutoLogonTDO.ps1 v------
function Disable-AutoLogonTDO{
        <#
        .SYNOPSIS
        Disable-AutoLogonTDO - Deconfigures autologon of the specified credential, after reboots (reverses Enable-AutoLogon821))
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Disable-AutoLogonTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-desktop
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Disable-AutoLogonTDO - Deconfigures autologon of the specified credential, after reboots (reverses Enable-AutoLogon821))
        .PARAMETER Credential
        Use specific Credentials[-Credentials [credential object]
        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Disable-AutoLogon
        .LINK
        https://github.org/tostka/verb-Desktop/
        #>
        [CmdletBinding()]
        [alias('Disable-AutoLogon821')]
        PARAM() ;
        $smsg = 'Disabling Automatic Logon'
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Remove-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -Name AutoAdminLogon -ErrorAction SilentlyContinue| out-null
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' ;
            Name = "AutoAdminLogon" ;          
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        #Remove-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -Name DefaultUserName -ErrorAction SilentlyContinue| out-null
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' ;
            Name = "DefaultUserName" ;
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        # Remove-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -Name DefaultPassword -ErrorAction SilentlyContinue| out-null
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' ;
            Name = "DefaultPassword" ;       
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
    }

#*------^ Disable-AutoLogonTDO.ps1 ^------


#*------v Disable-OpenFileSecurityWarningTDO.ps1 v------
function Disable-OpenFileSecurityWarningTDO{
        <#
        .SYNOPSIS
        Disable-OpenFileSecurityWarningTDO - Suppresses Open File - Security Warning popup prompts
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Disable-OpenFileSecurityWarningTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-io
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Disable-OpenFileSecurityWarningTDO - Suppresses Open File - Security Warning popup prompts        
        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Disable-OpenFileSecurityWarning
        .LINK
        https://github.org/tostka/verb-Desktop/
        #>
        [CmdletBinding()]
        [alias('Disable-OpenFileSecurityWarning821')]
        PARAM() ;
        $smsg = 'Disabling File Security Warning dialog'
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        # New-Item -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' -ErrorAction SilentlyContinue |out-null
        $pltnItm=[ordered]@{
            Path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' ;                       
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-Item w`n$(($pltnItm|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-Item @pltnItm | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        #New-ItemProperty 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' -name 'LowRiskFileTypes' -value '.exe;.msp;.msu;.msi' -ErrorAction SilentlyContinue |out-null
        $pltnIP=[ordered]@{
            Path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' ;
            Name = "LowRiskFileTypes" ;
            Value = '.exe;.msp;.msu;.msi' ;            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        #New-Item -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' -ErrorAction SilentlyContinue |out-null
        $pltnItm=[ordered]@{
            Path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' ;                       
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-Item w`n$(($pltnItm|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-Item @pltnItm | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        #New-ItemProperty 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' -name 'SaveZoneInformation' -value 1 -ErrorAction SilentlyContinue |out-null
        $pltnIP=[ordered]@{
            Path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' ;
            Name = "SaveZoneInformation" ;
            Value = 1 ;            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        # Remove-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' -Name 'LowRiskFileTypes' -ErrorAction SilentlyContinue
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' ;   
            Name = 'LowRiskFileTypes' ;
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
        # Remove-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' -Name 'SaveZoneInformation' -ErrorAction SilentlyContinue
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' ;   
            Name = 'SaveZoneInformation' ; 
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
    }

#*------^ Disable-OpenFileSecurityWarningTDO.ps1 ^------


#*------v Disable-UACTDO.ps1 v------
function Disable-UACTDO{
        <#
        .SYNOPSIS
        Disable-UACTDO - Disables User Account Control
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Disable-UACTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-io
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Disable-UACTDO - Disables User Account Control        
        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Disable-UAC
        .LINK
        https://github.org/tostka/verb-Desktop/
        #>
        [CmdletBinding()]
        [alias('Disable-UAC821')]
        PARAM( ) ;
        $smsg = 'Disabling User Account Control'
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #New-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' -Name EnableLUA -Value 0 -ErrorAction SilentlyContinue| out-null
        $pltnIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' ;
            Name = "EnableLUA" ;
            Value = 0            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;     
    }

#*------^ Disable-UACTDO.ps1 ^------


#*------v Enable-AutoLogonTDO.ps1 v------
function Enable-AutoLogonTDO{
        <#
        .SYNOPSIS
        Enable-AutoLogonTDO - Configures autologon of the specified credential, after reboots (reverse with Disable-OpenFileSecurityWarningTDO)
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Enable-AutoLogonTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-desktop
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Enable-AutoLogonTDO - Configures autologon of the specified credential, after reboots (reverse with Disable-OpenFileSecurityWarningTDO)
        .PARAMETER Credential
        Use specific Credentials[-Credentials [credential object]
        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Enable-AutoLogon
        .LINK
        https://github.org/tostka/verb-Desktop/
        #>
        [CmdletBinding()]
        [alias('Enable-AutoLogon821')]
        PARAM(
            [Parameter(Mandatory = $false, HelpMessage = "Use specific Credentials[-Credentials [credential object]")]
                [System.Management.Automation.PSCredential]$Credential
         ) ;
        $smsg = 'Enabling Automatic Logon'
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #$PlainTextPassword= [Runtime.InteropServices.Marshal]::PtrToStringAuto([Runtime.InteropServices.Marshal]::SecureStringToBSTR( (ConvertTo-SecureString $State['AdminPassword']) ))
        #$PlainTextAccount= $State['AdminAccount']
        $PlainTextAccount= $Credential.UserName ; 
        $PlainTextPassword= $Credential.GetNetworkCredential().Password  ;
        #New-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -Name AutoAdminLogon -Value 1 -ErrorAction SilentlyContinue| out-null
        $pltnIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' ;
            Name = "AutoAdminLogon" ;
            Value = 1 ;            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        #New-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -Name DefaultUserName -Value $PlainTextAccount -ErrorAction SilentlyContinue| out-null
        $pltnIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' ;
            Name = "DefaultUserName" ;
            Value = $PlainTextAccount ;            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        # New-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' -Name DefaultPassword -Value $PlainTextPassword -ErrorAction SilentlyContinue| out-null 
        $pltnIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon' ;
            Name = "DefaultPassword" ;
            Value = $PlainTextPassword ;            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
    }

#*------^ Enable-AutoLogonTDO.ps1 ^------


#*------v Enable-OpenFileSecurityWarningTDO.ps1 v------
function Enable-OpenFileSecurityWarningTDO{
        <#
        .SYNOPSIS
        Enable-OpenFileSecurityWarningTDO - Restores Open File - Security Warning popup prompts.
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Enable-OpenFileSecurityWarningTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-io
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Enable-OpenFileSecurityWarningTDO - Restores Open File - Security Warning popup prompts.

        Re-enables default behavior for popups like:
        ```text
        Title: Open File - Security Warning
        [app icon]
        Name: d:\programs...\xxx.exe
        Publisher: Unknown Publisher
        Type: Application
        From: d:\programs...\xxx.exe
        [Run] [Cancel]
        [ ] Always ask before opening this file
        [x shield icon] This file does not have a valid digital signature that verifies its
        publisher. You should only run software form publishers you trust. 
        ```
        Effectively clears added entries from the LowRiskFileTypes reg key, used after completion of build/updates.        

        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Enable-OpenFileSecurityWarning
        .LINK
        https://github.org/tostka/verb-Desktop/
        #>
        [CmdletBinding()]
        [alias('Enable-OpenFileSecurityWarning821')]
        PARAM() ;
        $smsg = "Enabling File Security Warning dialog"
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #Remove-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' -Name 'LowRiskFileTypes' -ErrorAction SilentlyContinue
        $pltrvIP=[ordered]@{
            Path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' ;
            Name = "LowRiskFileTypes" ;          
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ; 
        #Remove-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' -Name 'SaveZoneInformation' -ErrorAction SilentlyContinue
        $pltrvIP=[ordered]@{
            Path = 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' ;
            Name = "SaveZoneInformation" ;
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;  
        # Remove-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' -Name 'LowRiskFileTypes' -ErrorAction SilentlyContinue
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Associations' ;
            Name = "LowRiskFileTypes" ;       
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
        #Remove-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' -Name 'SaveZoneInformation' -ErrorAction SilentlyContinue
        $pltrvIP=[ordered]@{
            Path = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Policies\Attachments' ;
            Name = "SaveZoneInformation" ;       
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "Remove-ItemProperty w`n$(($pltrvIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            Remove-ItemProperty @pltrvIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;
    }

#*------^ Enable-OpenFileSecurityWarningTDO.ps1 ^------


#*------v Enable-RunOnceTDO.ps1 v------
function Enable-RunOnceTDO{
        <#
        .SYNOPSIS
        Enable-RunOnceTDO - Configures specified ScriptFullname powershell script into the local RunOnce registrykey (will autorun one time, on next startup)
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Enable-RunOnceTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-io
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            add splatting on the new-itemprop, to store the settings being set;  
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Enable-RunOnceTDO - Configures specified ScriptFullname powershell script into the local RunOnce registrykey (will autorun one time, on next startup)
        .PARAMETER ScriptFullName
        Powershell script fullpath to be run at next startup   
        .PARAMETER Arguments
        String of commandline Arguments to be used with specified ScriptFullName
        .INPUTS
        None, no piped input.
        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Enable-RunOnce -ScriptFullName c:\pathto\scripttorun.ps1 -Arguments $Arguments
        .LINK
        https://github.org/tostka/verb-Network/
        #>
        [CmdletBinding()]
        [alias('Enable-RunOnce821')]
        PARAM(
            [Parameter(HelpMessage = "Powershell script fullpath to be run at next startup")]
                [system.io.fileinfo]$ScriptFullName,
            [Parameter(HelpMessage = "String of commandline Arguments to be used with specified ScriptFullName")]
                [string]$Arguments
        ) ;
        $smsg = "Set script to run once after reboot" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        <# 
        ### powershell.exe commandline params:
        -NoProfile
        This is a parameter that starts a PowerShell session without loading the user's PowerShell profile scripts ($PROFILE). A profile script is a file that runs automatically when a new PowerShell session is started to customize the environment.
            Purpose: Ensures a clean, consistent PowerShell environment, which is especially useful for automated tasks, scripts, or troubleshooting.
            Command example: powershell.exe -NoProfile
        -ExecutionPolicy
        This is a parameter that sets the execution policy for a specific PowerShell session. The execution policy is a safety feature that controls the conditions under which PowerShell loads configuration files and runs scripts.
            Purpose: Temporarily overrides the system's configured execution policy for a single session.
            Command example: powershell.exe -ExecutionPolicy Bypass
            Important note: The -ExecutionPolicy parameter for powershell.exe only affects the current session and does not change the permanent system setting.
        -Command
        This parameter instructs PowerShell to run specific commands or scripts and then exit the session, unless the -NoExit parameter is also used.
            Purpose: Execute commands directly from the command line without having to open an interactive PowerShell session.
            Command example: powershell.exe -Command "& {Get-Process}"
            Usage: For complex commands or script blocks, enclose them in curly braces {}. For simple commands or scripts, you can pass them as a string.
        InstallPath
        This term refers to the location where PowerShell stores modules and is not a command-line argument for powershell.exe. You can find these paths by checking the $env:PSModulePath environment variable.
            Default module paths on Windows:
                All users: %ProgramFiles%\PowerShell\Modules (for PowerShell 7) or %ProgramFiles%\WindowsPowerShell\Modules (for Windows PowerShell 5.1).
                Current user: $HOME\Documents\PowerShell\Modules (for PowerShell 7) or $HOME\Documents\WindowsPowerShell\Modules (for Windows PowerShell 5.1).
        #>
        <# If just running script, no params, use -file:        
        –noprofile –executionpolicy bypass –file "pathtoscript.ps1" ;

        #If need passed in params use -command and '&' invoke :
        Add argument (optional): 
        –noprofile –executionpolicy bypass  -Command "& c:\scripts\hello.ps1 -a 2 -b 3"
        Use nested quote/single-quotes if needed to accom spaces in parms/paths 
        –noprofile –executionpolicy bypass  -Command "& 'c:\path with spaces\hello.ps1' -a 2 -b 3 -c 'param with spaces'" 
        -noprofile -executionpolicy Unrestricted -Command "& c:\scripts\monitor-ADAccountLock.ps1 -NoLoop -verbose"
        #>
        $cmdline = "'$($ScriptFullName.fullname)'" ;         
        #$RunOnce= "$PSHome\powershell.exe -NoProfile -ExecutionPolicy Unrestricted -Command `"& `'$ScriptFullName.fullname`' -InstallPath `'$InstallPath`'`""
        # -installpath above is the 'arguments' on the specified runonce command/script, not a required parameter of powershell
        if($Arguments){
            #$RunOnce= "$PSHome\powershell.exe -NoProfile -ExecutionPolicy Unrestricted -Command `"& `'$ScriptFullName.fullname`' $($Arguments)`""
            $cmdline += " $($Arguments) " ; 
            $RunOnce= "$PSHome\powershell.exe -NoProfile -ExecutionPolicy Unrestricted -Command $($cmdline)" ; 
        } else { 
            $RunOnce= "$PSHome\powershell.exe -NoProfile -ExecutionPolicy Unrestricted -File $($cmdline)" ; 
        }
        $smsg = "RunOnce: $RunOnce"
        if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
            if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
        } ;
        # scriptname specs the key name below RunOnce, it's an arbitrary identifer for the runonce target: split the $ScriptFullName  to get the value dyn
        #New-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' -Name "$ScriptName"  -Value "$RunOnce" -ErrorAction SilentlyContinue| out-null        
        # flip to asplat        
        $pltnIP=[ordered]@{
            Path = 'HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce' ;
            Name = "$(split-path $ScriptFullName.fullname -leaf)" ;
            Value = "$RunOnce"            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;     
    }

#*------^ Enable-RunOnceTDO.ps1 ^------


#*------v Enable-UACTDO.ps1 v------
function Enable-UACTDO{
        <#
        .SYNOPSIS
        Enable-UACTDO - Enables User Account Control
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250917-0114PM
        FileName    : Enable-UACTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-desktop
        Tags        : Powershell,ActiveDirectory,Forest,Domain
        AddedCredit : Michel de Rooij / michel@eightwone.com
        AddedWebsite: http://eightwone.com
        AddedTwitter: URL        
        REVISIONS
        * 4:41 PM 10/6/2025 fixed comment brackets ; 
        * 3:00 PM 9/18/2025 port to vdesk from xopBuildLibrary; add CBH, and Adv Function specs ; 
            remove the write-my*() support (defer to native w-l support)
        * 10:45 AM 8/6/2025 added write-myOutput|Warning|Verbose support (for xopBuildLibrary/install-Exchange15.ps1 compat) 
        .DESCRIPTION
        Enable-UACTDO - Enables User Account Control
        .OUTPUTS
        None
        .EXAMPLE ; 
        PS> Enable-UAC
        .LINK
        https://github.org/tostka/verb-Desktop/
        #>
        [CmdletBinding()]
        [alias('Enable-UAC821')]
        PARAM( ) ;
        $smsg = 'Enabling User Account Control'
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level PROMPT } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        #New-ItemProperty -Path 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' -Name EnableLUA -Value 1 -ErrorAction SilentlyContinue| out-null
        $pltnIP=[ordered]@{
            Path = 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System' ;
            Name = "EnableLUA" ;
            Value = 1 ;            
            erroraction = 'SilentlyContinue' ; 
        } ;        
        $smsg = "New-ItemProperty w`n$(($pltnIP|out-string).trim())" ; 
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
        TRY{
            New-ItemProperty @pltnIP | out-null ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
        } ;     
    }

#*------^ Enable-UACTDO.ps1 ^------


#*------v get-localNicsTDO.ps1 v------
function get-localNicsTDO {
        <#
        .SYNOPSIS
        get-localNicsTDO - Quick summary of local Drives, encapsulates highlights of Get-NetAdapter, get-netipaddress & Get-NetIPInterface. 
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2025-07-17
        FileName    : get-localNicsTDO.ps1
        License     : MIT License
        Copyright   : (c) 2025 Todd Kadrie
        Github      : https://github.com/tostka/verb-network
        Tags        : Powershell
        AddedCredit : REFERENCE
        AddedWebsite: URL
        AddedTwitter: URL
        REVISIONS
        * 10:06 AM 8/14/2025 add: -NoAutoIP & -NoDhcp params, to exclude wo need to postfilter ;  ren: show-localNicsTDO -> get-localNicsTDO, alias orig name
        * 3:40 PM 8/13/2025 init, added to xopBuildLibary.ps1 & verb-network
        .DESCRIPTION
        get-localNicsTDO - Quick summary of local Drives, encapsulates highlights of Get-NetAdapter, get-netipaddress & Get-NetIPInterface. 

        Returns PSCustomObject array with following properties:

            A typical Static IPv4 Nic:

            Name                 : Ethernet
            Status               : Up
            LinkSpeed            : 10 Gbps
            MediaType            : 802.3
            MediaConnectionState : Connected
            ifIndex              : 2
            ifDesc               : vmxnet3 Ethernet Adapter
            ipAddress            : 123.456.9.6
            ipInterfaceIndex     : 2
            ipInterfaceAlias     : Ethernet
            ipAddressFamily      : IPv4
            ipType               : Unicast
            ipPrefixLength       : 24
            ipiInterfaceMetric   : 15
            isDHCP               : False
            isAutoIPRange        : False

            A typcial unconfigured DHCP nic defaulting to APIPA auto-ip.

            Name                 : Ethernet1
            Status               : Up
            LinkSpeed            : 10 Gbps
            MediaType            : 802.3
            MediaConnectionState : Connected
            ifIndex              : 4
            ifDesc               : vmxnet3 Ethernet Adapter #2
            ipAddress            : 169.254.167.181
            ipInterfaceIndex     : 4
            ipInterfaceAlias     : Ethernet1
            ipAddressFamily      : IPv4
            ipType               : Unicast
            ipPrefixLength       : 16
            ipiInterfaceMetric   : 15
            isDHCP               : True
            isAutoIPRange        : True

            - isAutoIPRange reflects a simple regex test of ipAddress against '^169\.254\.' 
                (the Automatic Private IP Addressing (APIPA) range 169.254.0.1 to 169.254.255.254).
            - ipiInterfaceMetric (from Get-NetIPInterface) can be used to resolve binding order: Lower metric is prioritized (e.g. lower is higher in the binding order).

        .PARAMETER NoAutoIP
        Switch to exclude APIPA auto-assigned IP nics (unconfigured)
        .PARAMETER NoDHCP
        Switch to exclude DHCP-enabled nics (static-IP only returned)
        .INPUTS
        None. Does not accepted piped input.
        .OUTPUTS
        System.Object[] summary properties
        .EXAMPLE
        PS> $localNics = get-localNicsTDO | ?{-not $_.isAutoIPRange} ; 
        PS> $localNics  ; 
        
            Name                 : Ethernet
            Status               : Up
            LinkSpeed            : 10 Gbps
            MediaType            : 802.3
            MediaConnectionState : Connected
            ifIndex              : 2
            ifDesc               : vmxnet3 Ethernet Adapter
            ipAddress            : 123.456.9.6
            ipInterfaceIndex     : 2
            ipInterfaceAlias     : Ethernet
            ipAddressFamily      : IPv4
            ipType               : Unicast
            ipPrefixLength       : 24
            ipiInterfaceMetric   : 15
            isDHCP               : False
            isAutoIPRange        : False
         
        Demo typical pass, with postfilter to exclude isAutoIPRange nics (APIPA, e.g. unconfigured, non-Static/non-DHCP)
        .EXAMPLE
        PS> $localNics = get-localNicsTDO -NoAutoIP -NoDHCP} ; 
        PS> $localNics  ; 
        
            Name                 : Ethernet
            Status               : Up
            LinkSpeed            : 10 Gbps
            MediaType            : 802.3
            MediaConnectionState : Connected
            ifIndex              : 2
            ifDesc               : vmxnet3 Ethernet Adapter
            ipAddress            : 123.456.9.6
            ipInterfaceIndex     : 2
            ipInterfaceAlias     : Ethernet
            ipAddressFamily      : IPv4
            ipType               : Unicast
            ipPrefixLength       : 24
            ipiInterfaceMetric   : 15
            isDHCP               : False
            isAutoIPRange        : False
         
        Demo typical pass, using -NoAutoIP & -NoDhcp (vs post filtering in frst demo)
        .LINK
        https://github.com/tostka/verb-network
        #>
        [CmdletBinding()]
        [Alias('show-localNicsTDO','get-localNics')]
        PARAM(
            [Parameter(Mandatory = $false, HelpMessage = "Switch to exclude APIPA auto-assigned IP nics (unconfigured)")]
                [switch]$NoAutoIP,
            [Parameter(Mandatory = $false, HelpMessage = "Switch to exclude DHCP-enabled nics (static-IP only returned)")]
                [switch]$NoDHCP
        );
        TRY{
            $nicsActive = Get-NetAdapter | ?{$_.Status -eq 'Up' -AND $_.MediaConnectionState -eq 'Connected'}; 
            $nics = @() ; 
            $nicsActive | foreach-object{        
                $thisnic = $_ ; 
                $nicInfo = [ordered]@{                    
                    Name = $thisnic.Name ;  # Ethernet
                    Status = $thisnic.Status ; # Up
                    LinkSpeed = $thisnic.LinkSpeed ; # 10 Gbps
                    MediaType = $thisnic.MediaType ; # 802.3
                    MediaConnectionState = $thisnic.MediaConnectionState ; # Connected
                    ifIndex = $thisnic.ifIndex ; # 2
                    ifDesc = $thisnic.ifDesc ; # vmxnet3 Ethernet Adapter    
                    ipAddress = $null ; # 123.456.9.6
                    ipInterfaceIndex = $null ; # 2
                    ipInterfaceAlias = $null ; # Ethernet
                    ipAddressFamily = $null ; # IPv4
                    ipType = $null ; # Unicast
                    ipPrefixLength = $null ; # 24
                    ipiInterfaceMetric = $null ; 
                    isDHCP = $null ; 
                    isAutoIPRange = $false ; 
                } ; 
                if($ipInfo = $thisnic | get-netipaddress){
                    $nicInfo.ipAddress = $ipInfo.ipAddress ; # 123.456.9.6
                    if($nicInfo.ipAddress -match '^169\.254\.'){
                        $nicInfo.isAutoIPRange = $true ;
                        $smsg = "NIC:$($nicInfo.name) is unused APIPA/AutoIP'd!: $($nicInfo.ipAddress)" ;
                        if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;                
                        } ;
                    } ; 
                    $nicInfo.ipInterfaceIndex =$ipInfo.InterfaceIndex ; # 2
                    $nicInfo.ipInterfaceAlias =$ipInfo.InterfaceAlias ; # Ethernet
                    $nicInfo.ipAddressFamily =$ipInfo.AddressFamily ; # IPv4
                    $nicInfo.ipType =$ipInfo.Type ; # Unicast
                    $nicInfo.ipPrefixLength =$ipInfo.PrefixLength ; # 24
                    if($ipBindInfo = $thisnic | Get-NetIPInterface |?{$_.ConnectionState -eq 'Connected'}){
                        $nicInfo.ipiInterfaceMetric = $ipBindInfo.InterfaceMetric ; 
                        $nicInfo.isDHCP = [boolean]($ipBindInfo.dhcp -eq 'Enabled')
                    } else { write-warning "No Get-NetIPInterface data returned" } 
                } else { write-warning "No get-netipaddress data returned" } ; 
                $nics += @([pscustomobject]$nicInfo)
            } ; 
            if($NoAutoIP){
                $nics = $nics |?{-not $_.isAutoIPRange} ; 
            }
            if($NoDhcp){
                $nics = $nics |?{-not $_.isDHCP} ; 
            } ; 
            $nics | write-output ; 
        } CATCH {
            $ErrTrapd=$Error[0] ;
            $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
            if(gcm Write-MyWarning -ea 0){Write-MyWarning $smsg } else {
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
        } ; 
    }

#*------^ get-localNicsTDO.ps1 ^------


#*------v Get-MyPackageTDO.ps1 v------
Function Get-MyPackageTDO () {
            <#
            .SYNOPSIS
            Get-MyPackageTDO - Given 1) an installable's downloaded source Url, 2) the matching downloaded installable FileName, and 3) the Path that the download should be findable within: This tests for a pre-downloaded Filename at the InstallPath specified, and if not found, downloads the specified URL (via Start-BitsTransfer), to the InstallPath\Filename. 
            .NOTES
            Version     : 0.0.1
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2025-08-15
            FileName    : Get-MyPackageTDO.ps1
            License     : (none asserted)
            Copyright   : (none asserted)
            Github      : https://github.com/tostka/verb-IO
            Tags        : Powershell,FileSystem,Backup,Development,Build,Staging
            AddedCredit :  Michel de Rooij / michel@eightwone.com
            AddedWebsite: https://eightwone.com / https://github.com/michelderooij/Install-Exchange15
            AddedTwitter: URL
            REVISIONS
            * 11:34 AM 8/15/2025 ren: Get-MyPackage -> Get-MyPackageTDO and alias the orig name;  add: CBH, fleshed out Parameter specs into formal well specified block. Added variety of working examples, for reuse adding future patches/packages to the mix.
            * 821's posted copy w/in install-Exchange15.ps1: Version 4.13, July 17th, 2025 821 install-Exchange15.ps1 func
            .DESCRIPTION
            Get-MyPackageTDO - Given 1) an installable's downloaded source Url, 2) the matching downloaded installable FileName, and 3) the Path that the download should be findable within: This tests for a pre-downloaded Filename at the InstallPath specified, and if not found, downloads the specified URL (via Start-BitsTransfer), to the InstallPath\Filename. 

            .INPUTS
            None. Does not accepted piped input.(.NET types, can add description)
            .OUTPUTS            
            System.Boolean
            .PARAMETER Package
            Microsoft's description for the update (used to echo status updates to log & console)[-Package 'Hotfix Update for Exchange Server 2016 CU23 HU16']
            .PARAMETER URL
            Microsoft's direct download URL for direct download, if local copy is unavailable (unprompted, no confirm prompt; may need to research into scripting & desktop automation cites to find the working url)[-URL 'https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe']
            .PARAMETER FileName
            Microsoft's filename for the downloaded file (used to check for local copy and avoid redownload)[-FileName 'Exchange2016-KB5057653-x64-en.exe']
            .PARAMETER InstallPath
            Parent directory path containing target .msu|.msi|.msp|.exe etc [-InstallPath c:\pathto\]
            .EXAMPLE
            PS> Get-MyPackageTDO -Package "Microsoft .NET Framework 4.8.1" -FileName "NDP481-x86-x64-AllOS-ENU.exe" '' -FileName "NDP481-x86-x64-AllOS-ENU.exe" -InstallPath $RunFrom
            Demo Test of .NET Framework 4.8.1 package             
            .LINK
            https://github.com/michelderooij/Install-Exchange15
            .LINK
            https://github.com/tostka/verb-io
            .LINK
            https://github.com/tostka/powershellbb/
            #>
            [CmdletBinding()]
            [Alias('Get-MyPackage')]
            PARAM ( 
                [Parameter(Position=0, HelpMessage="Microsoft's description for the update (used to echo status updates to log & console)[-Package 'Hotfix Update for Exchange Server 2016 CU23 HU16']")]
                    [string]$Package, 
                [Parameter(Position=1, HelpMessage="Microsoft's direct download URL for direct download, if local copy is unavailable (unprompted, no confirm prompt; may need to research into scripting & desktop automation cites to find the working url)[-URL 'https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe']")]
                    [String]$URL, 
                [Parameter(Position=2, HelpMessage="Microsoft's filename for the downloaded file (used to check for local copy and avoid redownload)[-FileName 'Exchange2016-KB5057653-x64-en.exe']")]
                    [String]$FileName, 
                [Parameter(Position=3, HelpMessage="Parent directory path containing target .msu|.msi|.msp|.exe etc [-InstallPath c:\pathto\]")]
                    [String]$InstallPath
            )
            $res= $true
            If( -not( Test-Path $(Join-Path $InstallPath $Filename))) {
                If( $URL) {
                    $smsg = "Package $Package not found, downloading to $FileName"
                    if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    Try{
                        $smsg = "Source: $URL"
                        if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                            if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        } ;
                        Start-BitsTransfer -Source $URL -Destination $(Join-Path $InstallPath $Filename)
                    }
                    Catch{
                        $smsg = "Problem downloading package from URL"
                        if(gcm Write-MyError -ea 0){Write-MyError $smsg } else {
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        $res= $false
                    }
                }
                Else {
                    $smsg = "$FileName not present, skipping"
                    if(gcm Write-MyWarning -ea 0){Write-MyWarning $smsg } else {
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    $res= $false
                }
            }
            Else {
                $smsg = "Located $Package ($InstallPath\$FileName)"
                if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                    if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ;
            }
            Return $res
        }

#*------^ Get-MyPackageTDO.ps1 ^------


#*------v get-OSFullVersionTDO.ps1 v------
Function get-OSFullVersionTDO {
        <#
        .SYNOPSIS
        get-OSFullVersionTDO - local OS Semantic Version number n.n.n.n, via get-cimInstance/get-WMIObject
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 20250929-1026AM
        FileName    : get-OSFullVersionTDO.ps1
        License     : MIT License
        Copyright   : (c) 2025 Todd Kadrie
        Github      : https://github.com/tostka/verb-desktop
        Tags        : Powershell,Storage,Drive,Drivespace
        AddedCredit : 
        AddedWebsite: 
        AddedTwitter: 
        REVISIONS
        * 12:12 PM 10/6/2025 add -MajorVersion & MinorVersion to return those sub-strings (support queries for the values in isolation); updated logic for the variant outputs.
        * 11:26 AM 9/29/2025 port from install-Exchnage15-TTC.ps1 into vdesk
        .DESCRIPTION
        get-OSFullVersionTDO - local OS Semantic Version number n.n.n.n, via get-cimInstance/get-WMIObject
       .PARAMETER MajorVersion
       Switch to return solely the MajorVersion value
       .PARAMETER MinorVersion        
        Switch to return solely the MinorVersion value
        .INPUTS
        None, no piped input.
        .OUTPUTS
        String Semantic Version
        .EXAMPLE
        PS> $OSSemVers = get-OSFullVersionTDO; 
        PS> $OSSemVers ; 
        
            10.0.19045          
        
        Demo call
        .EXAMPLE
        PS> if(get-variable -name State){
        PS>     $State['MajorSetupVersion'] = get-OSFullVersionTDO -MajorVersion ;
        PS>     $State['MinorSetupVersion'] = get-OSFullVersionTDO -MinorVersion ;
        PS> } else{
        PS>     #$SetupVersion = Get-FileVersionTDO $CabExSetup.fullname ;
        PS>     $MajorSetupVersion = get-OSFullVersionTDO -MajorVersion ;
        PS>     $MinorSetupVersion = get-OSFullVersionTDO -MinorVersion ;
        PS> } ; 
        Demo use of the -MajorVersion & -MinorVersion params
        .LINK
        https://github.org/tostka/verb-desktop/
        #>
        [CmdletBinding()]
        [alias('get-OSFullVersion')]
        PARAM(
            [Parameter(HelpMessage = "Switch to return solely the MajorVersion value[-MajorVersion]")]
                [switch]$MajorVersion,
            [Parameter(HelpMessage = "Switch to return solely the MinorVersion value[-MinorVersion]")]
                [switch]$MinorVersion
        ) ; 
        if($MajorVersion -AND $MinorVersion){
            $smsg = "*BOTH* -MajorVersion & -MinorVersion SPECIFIED: SPECIFY ONE OR THE OTHER!" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
            else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
            BREAK ; 
        } ; 
        if (get-command get-ciminstance -ea 0) {
            $OS = Get-ciminstance -class  Win32_OperatingSystem ; 
        } else {
            $OS = Get-WmiObject Win32_OperatingSystem ; 
        } ;
        $MajorOSVersion= [string]($OS| Select-Object @{n="Major";e={($_.Version.Split(".")[0]+"."+$_.Version.Split(".")[1])}}).Major ; 
        $MinorOSVersion= [string]($OS| Select-Object @{n="Minor";e={($_.Version.Split(".")[2])}}).Minor ; 
        $FullOSVersion= ('{0}.{1}' -f $MajorOSVersion, $MinorOSVersion) ;
        if($MajorVersion){
            $smsg = "-MajorVersion: returning to pipeline $($MajorVersion)" ;
            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
            $MajorVersion | write-output 
        } elseif($MinorVersion){
            $MinorOSVersion | write-output ; 
            $smsg = "-MinorOSVersion: returning to pipeline $($MinorOSVersion)" ;
            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
        }else{ 
            $smsg = "Returning FullOSVersionto pipeline $($FullOSVersion)" ;
            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
            $FullOSVersion | write-output  ;
        }
    }

#*------^ get-OSFullVersionTDO.ps1 ^------


#*------v get-processTitled.ps1 v------
Function get-processTitled {
    <#
    .SYNOPSIS
    get-processTitled.ps1 - Postfilter get-process, to display only processes with a MainWindowTitle
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2024-12-09
    FileName    : get-processTitled
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-desktop
    Tags        : Powershell,Process,Management,Reporting
    REVISIONS
    * 3:44 PM 12/9/2024init vers
    .DESCRIPTION
    get-processTitled.ps1 - Postfilter get-process, to display only processes with a MainWindowTitle
    Handy for tracking down the single *hung* powershell_ise instance, based on it's Titlebar contents (to targeted kill the problem; leaving the others to continue running).
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    System.Object process to pipeline
    .EXAMPLE
    PS> get-processTitled ; 

      ProcessName       Id MainWindowTitle
      -----------       -- ---------------
      explorer        5960 D:\scripts\logs
      powershell     12352 PS ADMIN - TORO - EMSt
      powershell_ise 12244 PS ADMIN - TORO -
    
    Default usage & output 
    .LINK
    https://github.com/tostka/verb-desktop
    #>
    [CmdletBinding()]
    #[Alias('','')]
    PARAM() ;
    get-process | ?{$_.mainwindowtitle} | sort processname,mainwindowtitle,id | select-object processname,id,mainwindowtitle | write-output 
}

#*------^ get-processTitled.ps1 ^------


#*------v install-ChocoPkg.ps1 v------
Function Install-ChocoPkg {
    <#
.SYNOPSIS
Install-ChocoPkg - runs $Packages list of choco pkgs through choco upgrade commmand (installs, if not pre-installed), parses choco exit codes and evals status.
.NOTES
Version     : 1.0.0
Author      : Todd Kadrie
Website     :	http://www.toddomation.com
Twitter     :	@tostka / http://twitter.com/tostka
CreatedDate : 2019-03-14
FileName    : Install-ChocoPkg.ps1
License     : MIT License
Copyright   : (c) 2020 Todd Kadrie
Github      : https://github.com/tostka
Tags        : Powershell
AddedCredit : REFERENCE
AddedWebsite:	URL
AddedTwitter:	URL
REVISIONS
* 12:34 PM 2/21/2023 duped into verb-desktop
* 2:09 PM 4/21/2020 added Source param (alt sources)
* 10:33 AM 3/14/2019 swap from 'choco install'/cist -> 'choco upgrade'/cup, also added the choco boxstarter path too long hack
.DESCRIPTION
.PARAMETER  Packages
Array of Chocolatey packages to Install
.PARAMETER  Source
Alternate Source [-source WindowsFeature
.PARAMETER ShowDebug
Parameter to display Debugging messages [-ShowDebug switch]
.PARAMETER Whatif
Parameter to run a Test no-change pass [-Whatif switch]
.EXAMPLE
$bRet = Install-ChocoPkg -Packages $pkgs -showdebug:$($showdebug) -whatif:$($whatif) ;
.LINK
#>
    Param(
        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Array of Chocolatey packages to Install")]
        [ValidateNotNullOrEmpty()][array]$Packages,
        [Parameter(HelpMessage = "Alternate Source [-source WindowsFeature")]
        [ValidateNotNullOrEmpty()][array]$Source,
        [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
        [switch] $showDebug,
        [Parameter(HelpMessage = "Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) # PARAM BLOCK END

    <# underlying Choco docs:
    Exit Codes

    Exit codes that normally result from running this command.

    Normal:
    -0: operation was successful, no issues detected
    --1 or 1: an error has occurred

    Package Exit Codes:
    -1641: success, reboot initiated
    -3010: success, reboot required
    -other (not listed): likely an error has occurred

    In addition to normal exit codes, packages are allowed to exit with their own codes when the feature 'usePackageExitCodes' is turned on. Uninstall command has additional valid exit codes. Available in v0.9.10+.

    Reboot Exit Codes:
    -350: pending reboot detected, no action has occurred
    -1604: install suspended, incomplete

    In addition to the above exit codes, you may also see reboot exit codes when the feature 'exitOnRebootDetected' is turned on. It typically requires the feature 'usePackageExitCodes' to also be turned on to work properly. Available in v0.10.12+.
    -----
    $chocoMsg = (choco install $myApp -y) -join('')

    if($chocoMsg -match "install of $myApp was successful.") {
        Write-Host -fo:green 'Success'
    } else {
        # handle errors
    }
    ----------
    Use exit codes to determine status.
    Chocolatey exits with 0 when everything worked appropriately and other exits codes like 1 when things error.
    There are package specific exit codes that are recommended to be used and reboot indicating exit codes as well.
    To check exit code when using PowerShell, immediately call $exitCode = $LASTEXITCODE to get the value choco exited with.

    Alternative Sources (-source)

    Available in 0.9.10+.
    Ruby
    This specifies the source is Ruby Gems and that we are installing a
    gem. If you do not have ruby installed prior to running this command,
    the command will install that first.
    e.g. choco install compass -source ruby
    WebPI
    This specifies the source is Web PI (Web Platform Installer) and that
    we are installing a WebPI product, such as IISExpress. If you do not
    have the Web PI command line installed, it will install that first and
    then the product requested.
    e.g. choco install IISExpress --source webpi
    Cygwin
    This specifies the source is Cygwin and that we are installing a cygwin
    package, such as bash. If you do not have Cygwin installed, it will
    install that first and then the product requested.
    e.g. choco install bash --source cygwin
    Python
    This specifies the source is Python and that we are installing a python
    package, such as Sphinx. If you do not have easy_install and Python
    installed, it will install those first and then the product requested.
    e.g. choco install sphinx --source python
    Windows Features
    This specifies that the source is a Windows Feature and we should
    install via the Deployment Image Servicing and Management tool (DISM)
    on the local machine.
    e.g. choco install IIS-WebServerRole --source windowsfeatures
    #>


    $ttl = ($Packages | measure).count ;
    $Procd = 0 ;
    $smsg = "Installing $($ttl)  Packages:" ;
    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
    foreach ($pkg in $Packages) {
        $Procd++ ;
        $error.clear() ;
        $chocoMsg = $null ;
        $sBnrS = "#*------v ($($Procd)/$($ttl)):choco upgrade -y $($pkg): v------" ;
        $smsg = "$($sBnrS)" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
        TRY {
            if (!$whatif) {
                if (!$Source) {
                    $chocoMsg = (choco upgrade --cacheLocation="$ChocoCachePath" -y $pkg) -join ('')
                } else {
                    $chocoMsg = (choco upgrade --cacheLocation="$ChocoCachePath" --source="$Source" -y $pkg) -join ('')
                } ;
                $exitCode = $LASTEXITCODE ;
            } else {
                if (!$Source) {
                    $chocoMsg = (choco upgrade --cacheLocation="$ChocoCachePath" -y $pkg --noop) -join ('')
                } else {
                    $chocoMsg = (choco upgrade --cacheLocation="$ChocoCachePath" --source="$Source" -y $pkg --noop) -join ('')
                } ;
                $exitCode = $LASTEXITCODE ;
            }
        } CATCH {
            $err = $_ ;
            $msg = ": Error Details: $($err)";
            Write-Error "$(get-date -format "HH:mm:ss"): FAILURE!" ;
            Write-Error "$(get-date -format "HH:mm:ss"): Error in $($err.InvocationInfo.ScriptName)." ;
            Write-Error "$(get-date -format "HH:mm:ss"): -- Error information" ;
            Write-Error "$(get-date -format "HH:mm:ss"): Line Number: $($err.InvocationInfo.ScriptLineNumber)" ;
            Write-Error "$(get-date -format "HH:mm:ss"): Offset: $($err.InvocationInfo.OffsetInLine)" ;
            Write-Error "$(get-date -format "HH:mm:ss"): Command: $($err.InvocationInfo.MyCommand)" ;
            Write-Error "$(get-date -format "HH:mm:ss"): Line: $($err.InvocationInfo.Line)" ;
            #Write-Error "$(get-date -format "HH:mm:ss"): Error Details: $($err)" ;
            $msg = ": Error Details: $($err)" ;
            Write-Error  "$(get-date -format "HH:mm:ss"): $($msg)" ;
            # 1:00 PM 1/23/2015 autorecover from fail, STOP (debug), EXIT (close), or use Continue to move on in loop cycle
            Continue ;
        }; # try/catch-E

        switch -Regex ($exitCode) {
            "0" {
                # operation was successful, no issues detected
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):Operation Was Successful, No Issues Detected" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
            }
            "((-)*)1" {
                # -1/1: an error has occurred
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):An Error Has Occurred" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; #Error|Warn
            } ;
            "1641" {
                # 1641: success, reboot initiated
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):Success, Reboot Initiated" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn
            }
            "3010" {
                # 3010: success, reboot required
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):Success, Reboot Required" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn
            }
            "350" {
                # 350: pending reboot detected, no action has occurred
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):Pending Reboot Detected, No Action Has Occurred" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn

            }
            "1604" {
                # 1604: install suspended, incomplete
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):Install Suspended, Incomplete" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; #Error|Warn
            }
            default {
                # other (not listed): likely an error has occurred
                $smsg = "$($pkg):`$LASTEXITCODE:$($exitCode):Unrecognized code - Likely An Error Has Occurred" ;
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error } ; #Error|Warn
            } ;
        } ;

        # 8:01 PM 3/18/2019 dump the output:
        if ($chocoMsg -match "install of $myApp was successful.") {
            Write-Host -fo:green 'Success' ;
        } else {
            # handle errors
        } ;

        if ($chocoMsg -match "A\spending\ssystem\sreboot\srequest\shas\sbeen\sdetected") {
            $smsg = "Pending Reboot detected." ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Warn } ; #Error|Warn|Debug
            $chocoMsg -match "Chocolatey\sv\d{1,}\.\d{1,}\.\d{1,}((\s)*)(.*Upgrading\sthe\sfollowing\spackages\:\w{1,})" ;
            $OutputSummary = $matches[3] ;
        } ;
        if ($chocoMsg -match "\.\w{1,}\s\sis\snot\sinstalled.\sInstalling...") {
            $smsg = "Installing:$($matches[1])" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            $chocoMsg -match "Chocolatey\sv\d{1,}\.\d{1,}\.\d{1,}((\s)*)(.*\s\sis\snot\sinstalled\.\sInstalling\.)" ;
            $OutputSummary = $matches[3] ;
        } ;
        if ($chocoMsg -match "\.\w{1,}\sv.*\sis\sthe\slatest\sversion\savailable\sbased\son\syour\ssource\(s\)\.") {
            $smsg = "Latest version currently installed" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            $chocoMsg -match "Chocolatey\sv\d{1,}\.\d{1,}\.\d{1,}((\s)*)(.*Chocolatey\supgraded\s\d{1,}/\d{1,}\spackages\.)" ;
            $OutputSummary = $matches[3] ;
        } ;
        if ($chocoMsg -match "Installing\.\.\.\w{1,}\snot\sinstalled\.\sThe\spackage\swas\snot\sfound\swith\sthe\ssource\(s\)\slisted\.") {
            $smsg = "Installing: Not installed, the pkg was not found with the source(s) listed" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            $chocoMsg -match "(Chocolatey\supgraded\s\d{1,}/\d{1,}\spackages\.\s\d{1,}\spackages\sfailed\.)" ;
            $OutputSummary = $matches[1] ;
        } elseif ($chocoMsg -match "Installing\.\.\.\w{1,}\snot\sinstalled\.") {
            $smsg = "Installing: Not installed (unknown)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            $chocoMsg -match "Chocolatey\supgraded\s\d{1,}\/\d{1,}\spackages.\s\d{1,}\spackages\sfailed\." ;
            $OutputSummary = $matches[0] ;
        };

        #$chocoMsg -match "^Chocolatey\sv\d{1,3}\.\d{1,3}\.\d{1,3}((\s)*)(.*(Installing...|Upgrading\sthe\sfollowing\spackages).*\sis\sthe\slatest\sversion\savailable\sbased\son\syour\ssource\(s\).Chocolatey\supgraded\s\d{1,3}\/\d{1,3}\spackages)" | out-null
        #"^Chocolatey\sv\d{1,3}\.\d{1,3}\.\d{1,3}((\s)*)(.*(Installing...|Upgrading\sthe\sfollowing\spackages))"
        #"^Chocolatey\sv\d{1,3}\.\d{1,3}\.\d{1,3}\s(.*(Installing...|Upgrading\sthe\sfollowing\spackages))"
        #"^Chocolatey\sv\d{1,3}\.\d{1,3}\.\d{1,3}\s(.*Installing...)"
        # "^(Chocolatey\sv\d{1,3}\.\d{1,3}\.\d{1,3}\s.*Installing...)" | out-null ;
        #$OutputSummary=$matches[3] ;
        #$matches[1] ;

        if (!(test-path "alias:out-clipboard")) { set-alias -Name out-clipboard -Value "$($env:WINDIR)\System32\clip.exe" };
        if (!$OutputSummary) {
            $smsg = "***UNPARSED `$chocoMsg!***`n(copied to cb)" ;
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn|Debug
            $chocoMsg | out-clipboard ;
        } ;
        $smsg = "`n$($pkg):#*---v $($pkg) Output v---`n$($OutputSummary)`n#*---^ $($pkg) Output ^---`n" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn

        $smsg = "$($sBnrS.replace('-v','-^').replace('v-','^-'))" ;
        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } ; #Error|Warn
    } ; # loop-E

}

#*------^ install-ChocoPkg.ps1 ^------


#*------v Install-ExePackage.ps1 v------
function Install-ExePackage {
	<#
    .SYNOPSIS
    Install-ExePackage.ps1 - Install EXE package via start-process
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20210415-0913AM
    FileName    : Install-ExePackage.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,Application,Install
	AddedCredit : skatterbrainzz
    AddedWebsite: https://skatterbrainz.wordpress.com/2016/12/19/building-an-sccm-1606-site-server-with-boxstarter-windows-server-2016-sql-server-2016/
    AddedTwitter: 
    REVISIONS
    * 3:13 PM 2/21/2023 added CBH, otb syntax. 
    * 12/19/2016 skatterbrainzz posted version
    .DESCRIPTION
    Install-ExePackage.ps1 - Install EXE package via start-process
    skatterbrainzz' function for box building, installation of .exe pkgs.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns either System.Boolean (default) or System.Object (-detail)
    .EXAMPLE
	PS>  $pltInstall = @{
	PS>  	prod    = "Windows Deployment Tools" ; 
	PS>  	appInst = "$adkSource\adksetup.exe" ; 
	PS>  	argList = " /Features OptionId.DeploymentTools OptionId.WindowsPreinstallationEnvironment OptionId.ImagingAndConfigurationDesigner OptionId.UserStateMigrationTool /norestart /quiet /ceip off" ; 
	PS>  } ; 
	PS>  Install-ExePackage @pltInstall ;
	Typical Install.
    .LINK
    https://github.com/tostka/verb-desktop
    https://skatterbrainz.wordpress.com/2016/12/19/building-an-sccm-1606-site-server-with-boxstarter-windows-server-2016-sql-server-2016/
    #>
    [CmdletBinding()]
	PARAM(
		[Parameter(Position=0,HelpMessage="Application Name substring[-ProductName 'Windows Deployment Tools']")]
		[string]$ProductName, 
		[Parameter(Position=1,HelpMessage="Application EXE installable[-Install 'path-to\adksetup.exe']")]
		$Install, 
		[Parameter(Position=2,HelpMessage="Application Name substring[-Options ' /Features OptionId.DeploymentTools OptionId.WindowsPreinstallationEnvironment OptionId.ImagingAndConfigurationDesigner OptionId.UserStateMigrationTool /norestart /quiet /ceip off']")]
		$Options
	) ; 
	if (Test-AppInstalled "$ProductName") {
		write-output "info: $ProductName is already installed." ; 
	}  else {
		write-output "info: installing $ProductName..." ; 
		write-output "info: type...... exe" ; 
		write-output "info: source.... $Install" ; 
		write-output "info: options... $Options" ; 
		try {
			$res = (Start-Process -FilePath "$Install" -ArgumentList "$Options" -Wait -PassThru).ExitCode ; 
			if ($res -ne 0) {
				write-output "error: exit code is $res" ; 
				$Boxstarter.RebootOk = $False ; 
				break ; 
			} else {
				write-output "info: exit code is $res" ; 
			} ; 
		}  catch {
			$ErrorMessage = $_.Exception.Message
			$FailedItem = $_.Exception.ItemName
			$Boxstarter.RebootOk = $False ; 
			write-output "error: installation failed... $ErrorMessage" ; 
			break ; 
		} ; 
		write-output "info: installation successful" ; 
		if (Test-PendingReboot) { Invoke-Reboot } ; 
	} ; 
}

#*------^ Install-ExePackage.ps1 ^------


#*------v Install-MsiPackage.ps1 v------
function Install-MsiPackage {
	<#
    .SYNOPSIS
    Install-MsiPackage.ps1 - Install MSI package via msiexec.exe
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20210415-0913AM
    FileName    : Install-MsiPackage.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,Application,Install
	AddedCredit : skatterbrainzz
    AddedWebsite: https://skatterbrainz.wordpress.com/2016/12/19/building-an-sccm-1606-site-server-with-boxstarter-windows-server-2016-sql-server-2016/
    AddedTwitter: 
    REVISIONS
    * 3:13 PM 2/21/2023 added CBH, otb syntax. 
    * 12/19/2016 skatterbrainzz posted version
    .DESCRIPTION
    Install-MsiPackage.ps1 - Install MSI package via msiexec.exe
    skatterbrainzz' function for box building, installation of msi pkgs.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns either System.Boolean (default) or System.Object (-detail)
    .EXAMPLE
    PS> Install-MsiPackage "Microsoft Deployment Toolkit (6.3.8443.1000)" "$mdtSource\MicrosoftDeploymentToolkit_x64.msi" "";
    Typical install.
    .LINK
    https://github.com/tostka/verb-desktop
    https://skatterbrainz.wordpress.com/2016/12/19/building-an-sccm-1606-site-server-with-boxstarter-windows-server-2016-sql-server-2016/
    #>
    [CmdletBinding()]
	PARAM(
		[Parameter(Position=0,HelpMessage="Application Name substring[-ProductName 'Microsoft Deployment Toolkit (6.3.8443.1000)']")]
		[string]$ProductName, 
		[Parameter(Position=1,HelpMessage="Application MSI installable[-Install 'path-to\MicrosoftDeploymentToolkit_x64.msi']")]
		$Install, 
		[Parameter(Position=2,HelpMessage="Application Name substring[-Options '']")]
		$Options
	) ; 
	if (Test-AppInstalled "$ProductName") {
		write-output "info: $ProductName is already installed" ; 
	} else {
		if (Test-Path "$Install") {
			write-output "info: installing $ProductName..." ; 
			write-output "info: type...... msi" ; 
			write-output "info: package... $Install" ; 
			write-output "info: options... $Options" ; 
			$Arg2 = "/i ""$Install"" /qb! /norestart REBOOT=ReallySuppress" ; 
			if ($Options -ne "") {
				$Arg2 += " ""$Options""" ; 
			} ; 
			TRY {
				$res = (Start-Process -FilePath "msiexec.exe" -ArgumentList $Arg2 -Wait -Passthru).ExitCode ; 
				if ($res -ne 0) {
					write-output "error: exit code is $res" ; 
					$errmsg = [ComponentModel.Win32Exception] $res ; 
					write-output "error: $errmsg" ; 
					$Boxstarter.RebootOk = $False ; 
					break ; 
				}  else {
				  write-output "info: exit code is $res" ; 
				} ; 
			}  CATCH {
				$Boxstarter.RebootOk = $False ; 
				write-output "error: installation failed!" ; 
				break ; 
			} ; 
			write-output "info: installation successful" ; 
			if (Test-PendingReboot) { Invoke-Reboot }
		}  else {
		  write-output "error: unable to locate $Install" ; 
		  break ; 
		} ; 
	} ; 
}

#*------^ Install-MsiPackage.ps1 ^------


#*------v Install-MyPackageTDO.ps1 v------
Function Install-MyPackageTDO {
            <#
            .SYNOPSIS
            Install-MyPackageTDO - MS patch/update installer, wraps Invoke-Process
            .NOTES
            Version     : 0.0.1
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2025-08-14
            FileName    : Install-MyPackageTDO.ps1
            License     : MIT License
            Copyright   : (c) 2025 Todd Kadrie
            Github      : https://github.com/tostka/verb-XXX
            Tags        : Powershell,FileSystem,Backup,Development,Build,Staging
            AddedCredit :  Michel de Rooij / michel@eightwone.com
            AddedWebsite: eightwone.com
            AddedTwitter: URL
            REVISIONS
            * 10:48 AM 10/6/2025 reworked demos; add var code for lack of $State[]; add alias Install-MyPackage
            * 12:06 PM 10/2/2025 ren Install-MyPackage -> Install-MyPackageTDO, alias original & 821 variant
            *11:15 AM 8/15/2025 add:explicit Position tags to params (PS default assumes in decl order, this codifies); fixed CBH param specs errors; brought in deferring $script varis from source; add: optional -FilePath, to backfill where $script scope $State['InstallPath'] isn't populated.
            * 5:17 PM 8/14/2025 add: CBH, fleshed out Parameter specs into formal well specified block. Added variety of working examples, for reuse adding future patches/packages to the mix.
            * 821's posted copy w/in install-Exchange15.ps1: Version 4.13, July 17th, 2025 821 install-Exchange15.ps1 func
            .DESCRIPTION
            Install-MyPackageTDO - MS patch/update installer, wraps Invoke-Process: Deps: Test-MyPackage, Get-MyPackage, Invoke-Extract, Write-MyOutput, Write-MyError, Write-MyVerbose'

            Tweaked variant of 821's function from his Install-Exchange15.ps1 script.
            
            ## DEMO update for a new package:

            # add the Exchange 2016 HU16 hotfix, sample at D:\cab\Ex2016CU23HU16-KB5057653\Exchange2016-KB5057653-x64-en.exe

            1. -PackageID: KBnnnnnn number - this is used by Test-MyPackage to do an HKLM reg install search, to verify install/pre-install. 
            2. -Package: Descriptive string from the KB doc article (used to echo/log status info).
            3. -FileName: copy the leaf filename to the filename spec;
            4. -OnlineURL: Hunt up an actual non-interactive download url from a scripting DSC/system automation forum or site. 
                (Doesn't work: find the spec page for it, click through the MSdownload link and grab the link on the download btn)
            5. -Arguments: suitable native install arguments supported by the package download (see other examples, or the package silent/passive installation docs).
            6. -NoDownload: seldom used, simply overrules existing package filename test, attempts to run the install direct from the download OnlineUrl (does not skip downloading, in spite of the name)  
            7. -FilePath: is an optional fall back outside of install-Exchange15.ps1 use, where InstallPath, $State['InstallPath'] is used as the RunFrom. 
                This is the directory the install package download is hosted from (or will be downloaded to).
              
            ```powershell
            PS> $PresenceKey= Test-MyPackage $PackageID ; 
            ```
            Test that checks for target kbnnnnn/guid

            [Download the package now](https://www.microsoft.com/download/details.aspx?familyID=1dcdfa24-ef09-483e-871e-28e699c7327c)
            => [Download](https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe)
           
            Raw download redirs into a form as: [Download](https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe)
            THATS the dl url, use it.

            ### Constructed call for the above:
            ```powershell
            PS> Install-MyPackageTDO -PackageID 'KB5057653' -Package 'Hotfix Update for Exchange Server 2016 CU23 HU16' -FileName 'Exchange2016-KB5057653-x64-en.exe' -OnlineURL 'https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe' -Arguments ('/passive')
            ```

            ###Splatted call
            ```powershell
            $pltisPkg=[ordered]@{
                PackageID = 'KB5057653' ;
                Package = 'Hotfix Update for Exchange Server 2016 CU23 HU16' ;
                FileName = 'Exchange2016-KB5057653-x64-en.exe' ;
                OnlineURL = 'https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe' ;
                Arguments = ('/passive') ; 
            } ;
            $smsg = "Install-MyPackageTDO w`n$(($pltisPkg|out-string).trim())" ; 
            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Info } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            Install-MyPackageTDO @pltisPkg ; 
            ```

            .INPUTS
            None. Does not accepted piped input.(.NET types, can add description)
            .OUTPUTS
            None. Returns no objects or output (.NET types)
            
            .PARAMETER PackageID
            Microsoft KB number or {GUID} (e.g. {41D635FE-4F9D-47F7-8230-9B29D6D42D31} or KB3206632) for the update as used in the Registry under \Uninstall, \Products, \Updates keys (used for install confirmation/detection) [-PackageID KB5057653]
            .PARAMETER Package
            Microsoft's description for the update (used to echo status updates to log & console)[-Package 'Hotfix Update for Exchange Server 2016 CU23 HU16']            
            .PARAMETER FileName
            Filename of target .msu|.msi|.msp|.exe etc [-FileName 'some.exe']
            .PARAMETER Arguments
            Suitable native .msu|.msi|.msp|.exe package parameters for a silent/passive install etc (those supported by the patch itself) [-Arguments ('/passive')]
            .PARAMETER NoDownload
            Switch to suppress download behavior (Doesn't suppress the download, assumes there's no downlaoded local copy: split-paths the -OnlineURL parent into a RunFrom to be Invoke-Process() installed)[-FilePath c:\pathto\]  
            PARAMETER .FilePath
            Optional: Parent directory path containing target file to be installed (install-Exchange15.ps1 defaults to `$State['InstallPath'])[-FilePath c:\pathto\]
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "-" -Package "Microsoft .NET Framework 4.8.1" -FileName "NDP481-x86-x64-AllOS-ENU.exe" -OnlineURL "https://download.microsoft.com/download/4/b/2/cd00d4ed-ebdd-49ee-8a33-eabc3d1030e3/NDP481-x86-x64-AllOS-ENU.exe" -Arguments ("/q", "/norestart")            
            Demo install of .NET Framework 4.8.1
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "KB3206632" -Package "Cumulative Update for Windows Server 2016 for x64-based Systems" -FileName "windows10.0-kb3206632-x64_b2e20b7e1aa65288007de21e88cd21c3ffb05110.msu" -OnlineURL "http://download.windowsupdate.com/d/msdownload/update/software/secu/2016/12/windows10.0-kb3206632-x64_b2e20b7e1aa65288007de21e88cd21c3ffb05110.msu" -Arguments ("/quiet", "/norestart")
            Demo install of Cumulative Update for Windows Server 2016 kb3206632 OS patch 
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "" -Package "Visual C++ 2012 Redistributable" -FileName "vcredist_x64_2012.exe" -OnlineURL "https://download.microsoft.com/download/1/6/B/16B06F60-3B20-4FF2-B699-5E9B7962F9AE/VSU_4/vcredist_x64.exe" -Arguments ("/install", "/quiet", "/norestart")
            Demo install of Visual C++ 2012 Redistributable
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "" -Package "Visual C++ 2013 Redistributable" -FileName "vcredist_x64_2013.exe" -OnlineURL "https://aka.ms/highdpimfc2013x64enu" -Arguments ("/install", "/quiet", "/norestart")
            Demo install of Visual C++ 2013 Redistributable
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "{9BCA2118-F753-4A1E-BCF3-5A820729965C}" -Package "URL Rewrite Module 2.1" -FileName "rewrite_amd64_en-US.msi" -OnlineURL "https://download.microsoft.com/download/1/2/8/128E2E22-C1B9-44A4-BE2A-5859ED1D4592/rewrite_amd64_en-US.msi" -Arguments ("/quiet", "/norestart")
            Demo install of URL Rewrite Module 2.1
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "{41D635FE-4F9D-47F7-8230-9B29D6D42D31}" -Package "Unified Communications Managed API 4.0 Runtime (Core)" -FileName "Setup.exe" (Join-Path -Path $State['SourcePath'] -ChildPath 'UcmaRedist\Setup.exe') -OnlineURL "" -Arguments ("/passive", "/norestart") -NoDownload
            Demo install of Unified Communications Managed API 4.0 Runtime (Core) (from the unpacked Exchange setup ISO, blank -OnlineURL)
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "{41D635FE-4F9D-47F7-8230-9B29D6D42D31}" -Package "Unified Communications Managed API 4.0 Runtime" -FileName "UcmaRuntimeSetup.exe" -OnlineURL "https://download.microsoft.com/download/2/C/4/2C47A5C1-A1F3-4843-B9FE-84C0032C61EC/UcmaRuntimeSetup.exe" -Arguments ("/passive", "/norestart")
            Demo install of Unified Communications Managed API 4.0 Runtime
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID "" -Package "Microsoft Edge Enterprise x64" -FileName "MicrosoftEdgeEnterpriseX64.msi" -OnlineURL "https://msedge.sf.dl.delivery.mp.microsoft.com/filestreamingservice/files/35f200dc-46f7-46fc-8f97-f29bf1babe1e/MicrosoftEdgeEnterpriseX64.msi" -Arguments @("/quiet", "/norestart") -NoDownload:$false
            Demo install of Microsoft Edge Enterprise x64
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID 'KB5049233' -Package 'Security Update For Exchange Server 2019 CU14 SU3 V2' -FileName 'Exchange2019-KB5049233-x64-en.exe' 'https://download.microsoft.com/download/8/0/b/80b356e4-f7b1-4e11-9586-d3132a7a2fc3/Exchange2019-KB5049233-x64-en.exe' -Arguments ('/passive')
            Demo install of Security Update For Exchange Server 2019 CU14 SU3 V2
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID 'KB5049233' -Package 'Security Update For Exchange Server 2019 CU13 SU7 V2' -FileName 'Exchange2019-KB5049233-x64-en.exe' -OnlineURL 'https://download.microsoft.com/download/4/e/5/4e5cbbcc-5894-457d-88c4-c0b2ff7f208f/Exchange2019-KB5049233-x64-en.exe' -Arguments ('/passive')
            Demo install of Security Update For Exchange Server 2019 CU13 SU7 V2
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID 'KB5049233' -Package 'Security Update For Exchange Server 2016 CU23 SU14 V2' -FileName 'Exchange2016-KB5049233-x64-en.exe' -OnlineURL 'https://download.microsoft.com/download/0/9/9/0998c26c-8eb6-403a-b97a-ae44c4db5e20/Exchange2016-KB5049233-x64-en.exe' -Arguments ('/passive')
            Demo install of Security Update For Exchange Server 2016 CU23 SU14 V2
            .EXAMPLE
            PS> Install-MyPackageTDO -PackageID 'KB5057653' -Package 'Hotfix Update for Exchange Server 2016 CU23 HU16' -FileName 'Exchange2016-KB5057653-x64-en.exe' -OnlineURL 'https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe' -Arguments ('/passive')
            Demo install of Hotfix Update for Exchange Server 2016 CU23 HU16
            .LINK
            https://github.com/tostka/verb-dev
            .LINK
            https://github.com/tostka/powershellbb/
            #>
            [CmdletBinding()]
            [Alias('Install-MyPackage')]
            PARAM ( 
                [Parameter(Position=0, HelpMessage="Microsoft KB number or {GUID} (e.g. {41D635FE-4F9D-47F7-8230-9B29D6D42D31} or KB3206632) for the update as used in the Registry under \Uninstall, \Products, \Updates keys (used for install confirmation/detection) [-PackageID KB5057653]")]
                    [String]$PackageID, 
                [Parameter(Position=1, HelpMessage="Microsoft's description for the update (used to echo status updates to log & console)[-Package 'Hotfix Update for Exchange Server 2016 CU23 HU16']")]
                    [string]$Package, 
                [Parameter(Position=2, HelpMessage="Microsoft's filename for the downloaded file (used to check for local copy and avoid redownload)[-FileName 'Exchange2016-KB5057653-x64-en.exe']")]
                    [String]$FileName, 
                [Parameter(Position=3, HelpMessage="Microsoft's direct download URL for direct download, if local copy is unavailable (unprompted, no confirm prompt; may need to research into scripting & desktop automation cites to find the working url)[-OnlineURL 'https://download.microsoft.com/download/1dcdfa24-ef09-483e-871e-28e699c7327c/Exchange2016-KB5057653-x64-en.exe']")]
                    [String]$OnlineURL, 
                [Parameter(Position=4, HelpMessage="Suitable native .msu|.msi|.msp|.exe package parameters for a silent/passive install etc (those supported by the patch itself) [-Arguments ('/passive')]")]
                    [array]$Arguments, 
                [Parameter(Position=5, HelpMessage="Switch to suppress download behavior (Doesn't suppress the download, assumes there's no downlaoded local copy: split-paths the -OnlineURL parent into a RunFrom to be Invoke-Process() installed)[-FilePath c:\pathto\]")]
                    [switch]$NoDownload,
                [Parameter(Position=6, HelpMessage="Optional: Parent directory path containing target file to be installed (install-Exchange15.ps1 defaults to `$State['InstallPath'])[-FilePath c:\pathto\]")]
                    [string]$FilePath
            )
            # dependant constants            
            if(-not $ERR_PROBLEMPACKAGESETUP){$ERR_PROBLEMPACKAGESETUP        = 1121} ; 
            if(-not $ERR_PROBLEMPACKAGEDL){$ERR_PROBLEMPACKAGEDL           = 1120};
            if(-not $ERR_PROBLEMPACKAGEEXTRACT){$ERR_PROBLEMPACKAGEEXTRACT      = 1122};
                        
            If( $PackageID) {
                $smsg = "Processing $Package ($PackageID)"
                if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ;
                # pretest for installation: 
                $PresenceKey= Test-MyPackage $PackageID
            }
            Else {
                # Just install, don't detect
                $smsg = "Processing $Package"
                if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ;
                $PresenceKey= $false
            }
            #$RunFrom= $State['InstallPath']
            # $State['InstallPath'] is a hashtable configured by install-Exchange15-TTC.ps1. In it's absence, fall back to local -FilePath.
            if($State['InstallPath']){
                $RunFrom= $State['InstallPath']
            }elseif($FilePath){
                $RunFrom = $FilePath
            }else{
                $smsg = "Neither `$State['InstallPath'] found, nor -FilePath specified!`nPlease specify at least one of the two!"
                $smsg = "`n$(($ErrTrapd | fl * -Force|out-string).trim())" ;
                if(gcm Write-MyError -ea 0){Write-MyError $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
                Exit "No RunFrom/InstallPath/FilePath specified" ; 
            }
            If( -not( $PresenceKey )){

                If( $FileName.contains('|')) {
                    # Filename contains filename (dl) and package name (after extraction)
                    $PackageFile= ($FileName.Split('|'))[1]
                    $FileName= ($FileName.Split('|'))[0]
                    If( -not( Get-MyPackage $Package '' $FileName $RunFrom)) {
                        # Download & Extract
                        If( -not( Get-MyPackage $Package $OnlineURL $PackageFile $RunFrom)) {
                            $smsg = "Problem downloading/accessing $Package"
                            if(gcm Write-MyError -ea 0){Write-MyError $smsg } else {
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                            Exit $ERR_PROBLEMPACKAGEDL
                        }
                        $smsg = "Extracting Hotfix Package $Package"
                        if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                        } ;
                        Invoke-ExtractTDO $RunFrom $PackageFile

                        If( -not( Get-MyPackage $Package $OnlineURL $PackageFile $RunFrom)) {
                            $smsg = "Problem downloading/accessing $Package"
                            if(gcm Write-MyError -ea 0){Write-MyError $smsg } else {
                                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                            } ;
                            Exit $ERR_PROBLEMPACKAGEEXTRACT
                        }
                    }
                }
                Else {
                    If( $NoDownload) {
                        $RunFrom= Split-Path -Path $OnlineURL -Parent
                        $smsg = "Will run $FileName straight from $RunFrom"
                        if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                            if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                        } ;

                    }
                    If( -not( Get-MyPackage $Package $OnlineURL $FileName $RunFrom)) {
                        $smsg = "Problem downloading/accessing $Package"
                        if(gcm Write-MyError -ea 0){Write-MyError $smsg } else {
                            if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                        } ;
                        Exit $ERR_PROBLEMPACKAGEDL
                    }
                }

                $smsg = "Installing $Package from $RunFrom"
                if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ;
                $rval= Invoke-ProcessTDO $RunFrom $FileName $Arguments

                If( $PackageID) {
                    $PresenceKey= Test-MyPackage $PackageID
                }
                Else {
                    # Don't check post-installation
                    $PresenceKey= $true
                }
                If( ( @(3010,-2145124329) -contains $rval) -or $PresenceKey)  {
                    switch ( $rval) {
                        3010: {
                            $smsg = "Installation $Package successful, reboot required"
                            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            } ;
                        }
                        -2145124329: {
                            $smsg = "$Package not applicable or blocked - ignoring"
                            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            } ;
                        }
                        default: {
                            $smsg = "Installation $Package successful"
                            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                            } ;
                        }
                    }
                }
                Else {
                    $smsg = "Problem installing $Package - For fixes, check $($ENV:WINDIR)\WindowsUpdate.log; For .NET Framework issues, check 'Microsoft .NET Framework 4 Setup' HTML document in $($ENV:TEMP)"
                    if(gcm Write-MyError -ea 0){Write-MyError $smsg } else {
                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level Error} else{ write-ERROR "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    } ;
                    Exit $ERR_PROBLEMPACKAGESETUP
                }
            }
            Else {
                $smsg = "$Package already installed"
                if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                    if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ;
            }
        }

#*------^ Install-MyPackageTDO.ps1 ^------


#*------v Install-ServerRoles.ps1 v------
function Install-ServerRoles {
	<#
    .SYNOPSIS
    Install-ServerRoles.ps1 - Install WindowsFeatures using saved xml file Add Roles and Features Wizard in Server Manager. 
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20210415-0913AM
    FileName    : Install-ServerRoles.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,Application,Install
	AddedCredit : skatterbrainzz
    AddedWebsite: https://skatterbrainz.wordpress.com/2016/12/19/building-an-sccm-1606-site-server-with-boxstarter-windows-server-2016-sql-server-2016/
    AddedTwitter: 
    REVISIONS
    * 3:13 PM 2/21/2023 added CBH, otb syntax. 
    * 12/19/2016 skatterbrainzz posted version
    .DESCRIPTION
    Install-ServerRoles.ps1 - Install WindowsFeatures using saved xml file Add Roles and Features Wizard in Server Manager.
    skatterbrainzz' function for box building, installation of WindowsFeatures.
    
    The XMLFile configuration file can be created by clicking Export configuration settings on the Confirm installation selections page of the Add Roles and Features Wizard in Server Manager.
    .PARAMETER XmlFile
	Path to xml file created by clicking Export configuration settings on the Confirm installation selections page of the Add Roles and Features Wizard in Server Manager[-XmlFile 'pathto\ServerRoles.xml']"
	.PARAMETER RoleNames
	Application Name substring[-RoleNames 'WDS']
	.PARAMETER sharedSource
	Path to common install share[-sharedSource '\\server\share\pathto\']
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns either System.Boolean (default) or System.Object (-detail)
    .EXAMPLE
    PS> Install-ServerRoles -XmlFile "$scriptsPath\ServerRoles.xml" -SharedSource $SharedSource ;
    Install saved .xml file of Server Manager Add Roles & Features Wiz Export
    .EXAMPLE
    Install-ServerRoles -RoleName "WDS"
    Install WindowsFeature by name
    .LINK
    https://github.com/tostka/verb-desktop
    https://skatterbrainz.wordpress.com/2016/12/19/building-an-sccm-1606-site-server-with-boxstarter-windows-server-2016-sql-server-2016/
    #>
	PARAM(
		[parameter(Mandatory=$False,Position=0,HelpMessage="Path to xml file created by clicking Export configuration settings on the Confirm installation selections page of the Add Roles and Features Wizard in Server Manager[-XmlFile 'pathto\ServerRoles.xml']")] 
		[string]$XmlFile = "", 
		[parameter(Mandatory=$False,Position=1,HelpMessage="Application Name substring[-RoleNames 'WDS']")] 
		[string[]]$RoleNames = "",
		[parameter(Mandatory=$False,HelpMessage="Path to common install share[-sharedSource '\\server\share\pathto\']")] 
		[string]$sharedSource = "\\FS1\Apps\Sources\2016\SXS" 
	) ; 
	if ($xmlFile -ne "") {
		if (Test-Path $xmlFile) {
			write-output "info: installing server roles and features from config file..." ; 
			Install-WindowsFeature -ConfigurationFilePath $xmlFile -Source $sharedSource ; 
			write-output "info: roles and features installation completed." ; 
		}  else {
			write-output "error: unable to locate configuration file: $xmlFile" ; 
			$Boxstarter.RebootOk = $False ; 
			break ; 
		} ; 
	}  else {
		write-output "info: installing server roles and features..." ; 
		try {
			Install-WindowsFeature -Name $RoleNames.Split(",") -IncludeManagementTools -Source $sharedSource -ErrorAction Stop ; 
		}  catch {
			$ErrorMessage = $_.Exception.Message
			$FailedItem = $_.Exception.ItemName
			$Boxstarter.RebootOk = $False ; 
			write-output "error: role names...... $RoleNames" ; 
			write-output "error: config file..... $XmlFile" ; 
			write-output "error: installation failed... $ErrorMessage" ; 
			break ; 
		} ; 
		Start-Sleep -s 10 ; 
	} ; 
}

#*------^ Install-ServerRoles.ps1 ^------


#*------v invoke-Explore.ps1 v------
Function invoke-Explore {
    <# 
    .SYNOPSIS
    invoke-Explore - Spawn explorer on designated path (aliased as 'explore')
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2021-10-04
    FileName    : invoke-Explore.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-Desktop
    Tags        : Powershell,explorer,Filesystem
    REVISIONS   :
    # 8:59 AM 8/25/2022 init
    .DESCRIPTION
    invoke-Explore - Spawn explorer on designated path
    .PARAMETER  Path
    Path to be overlayed over specified background    
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    PS> Explore c:\usr\local\bin\
    Invoke explorer.exe on specified path
    .LINK
    https://github.com/tostka/verb-Desktop
    #>
    [CmdletBinding()]
    [Alias('Explore')]
    Param(
        [Parameter(Mandatory=$true,Position = 0,ValueFromPipeline = $true,HelpMessage="Path to be 'explored'[-path 'c:\some\path']")]
        [ValidateNotNullOrEmpty()]
        [string]$Path
    ) ; 
    if((get-variable -name IsWindows) -AND (-not $IsWindows)){
        write-warning "Ps `$isWindows:$($isWindows): This funcion is *only* supported on *Windows*" ; 
        Break ; 
    } ;
    write-verbose "invoking explorer with -path:$($path)" ; 
    $explorer = New-Object -ComObject shell.application ; 
    $explorer.Explore($path) ; 
}

#*------^ invoke-Explore.ps1 ^------


#*------v Invoke-ExtractTDO.ps1 v------
Function Invoke-ExtractTDO {
            <#
            .SYNOPSIS
            Invoke-ExtractTDO - Given 1) an installable's downloaded source Url, 2) the matching downloaded installable FileName, and 3) the Path that the download should be findable within: This tests for a pre-downloaded Filename at the InstallPath specified, and if not found, downloads the specified URL (via Start-BitsTransfer), to the InstallPath\Filename. 
            .NOTES
            Version     : 0.0.1
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2025-08-15
            FileName    : Invoke-ExtractTDO.ps1
            License     : (none asserted)
            Copyright   : (none asserted)
            Github      : https://github.com/tostka/verb-IO
            Tags        : Powershell,FileSystem,Backup,Development,Build,Staging
            AddedCredit :  Michel de Rooij / michel@eightwone.com
            AddedWebsite: https://eightwone.com / https://github.com/michelderooij/Install-Exchange15
            AddedTwitter: URL
            REVISIONS
            * 11:34 AM 8/15/2025 ren: Invoke-Extract -> Invoke-ExtractTDO and alias the orig name;  add: CBH, fleshed out Parameter specs into formal well specified block. Added variety of working examples, for reuse adding future patches/packages to the mix.
            * 821's posted copy w/in install-Exchange15.ps1: Version 4.13, July 17th, 2025 821 install-Exchange15.ps1 func
            .DESCRIPTION
            Invoke-ExtractTDO - Given 1) an installable's downloaded source Url, 2) the matching downloaded installable FileName, and 3) the Path that the download should be findable within: This tests for a pre-downloaded Filename at the InstallPath specified, and if not found, downloads the specified URL (via Start-BitsTransfer), to the InstallPath\Filename. 

            .INPUTS
            None. Does not accepted piped input.(.NET types, can add description)
            .OUTPUTS            
            System.Boolean
            .PARAMETER FilePath
            Parent directory path containing target file to be extracted [-FilePath c:\pathto\]
            .PARAMETER FileName
            Filename for the file to be extracted[-FileName 'Exchange2016-KB5057653-x64-en.exe']        
            .EXAMPLE
            PS> Invoke-ExtractTDO -FilePath $RunFrom -FileName $PackageFile
            Demo Test use 
            .LINK
            https://github.com/michelderooij/Install-Exchange15
            .LINK
            https://github.com/tostka/verb-io
            .LINK
            https://github.com/tostka/powershellbb/
            #>
            [CmdletBinding()]
            [Alias('Invoke-Extract')]
            PARAM(
                [Parameter(Position=0, HelpMessage="Parent directory path containing target file to be extracted [-FilePath c:\pathto\]")]
                    $FilePath,
                [Parameter(Position=1, HelpMessage="Filename for the file to be extracted[-FileName 'Exchange2016-KB5057653-x64-en.exe']")]
                    [String]$FileName
            ) 
            $smsg = "Extracting $FilePath\$FileName to $FilePath"
            if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
            If( Test-Path $(Join-Path $FilePath $Filename)) {
                $TempNam= "$(Join-Path $FilePath $Filename).zip"
                Copy-Item $(Join-Path $FilePath $Filename) "$TempNam" -Force
                $shellApplication = new-object -com shell.application
                $zipPackage = $shellApplication.NameSpace( $TempNam)
                $destFolder = $shellApplication.NameSpace( $FilePath)
                $destFolder.CopyHere( $zipPackage.Items(), 0x10)
                Remove-Item $TempNam
            }
            Else {
                $smsg = "$FilePath\$FileName not found"
                if(gcm Write-MyWarning -ea 0){Write-MyWarning $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
            }
        }

#*------^ Invoke-ExtractTDO.ps1 ^------


#*------v Invoke-ProcessTDO.ps1 v------
Function Invoke-ProcessTDO {
        <#
        .SYNOPSIS
        Invoke-ProcessTDO - Start-Process wrapper that runs 'MSU|MSI|MSP|EXE' etc files with command line parameters, and returns Exitcode (and captured stdOut/stdErr, with -Passthru parameter)
        .NOTES
        Version     : 0.0.1
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2025-08-14
        FileName    : Invoke-ProcessTDO
        License     : MIT License
        Copyright   : (c) 2025 Todd Kadrie
        Github      : https://github.com/tostka/verb-XXX
        Tags        : Powershell,FileSystem,Backup,Development,Build,Staging
        AddedCredit :  Michel de Rooij / michel@eightwone.com
        AddedWebsite: eightwone.com
        AddedTwitter: URL
        REVISIONS
        * 2:41 PM 8/15/2025 added dotcrawl when non-verbose ; 
            flipped Start-Process -NoNewWindow (still pops win) to -WindowStyle Hidden (work around bug dur to use with -redir's)
            updated wlt to support wlty's; added to xopBuildLibrary.ps1, set xopBuildLibarary\Invoke-Process821() to defer to this if pre-loaded.
        * 3:37 PM 8/14/2025 ren Invoke-Process821 -> Invoke-ProcessTDO (substantial upgraded code), aliased orig name ; 
            added updated CBH demo; add: -silent param;  
            add: CBH; -PassThru param (make it return output of underlying cmd), which returns a SytstemObject summary with ExitCode, StdOut, StdErr & process Handle.
        * MdR's posted Version 4.13, July 17th, 2025 of install-Exchange15.ps1
        .DESCRIPTION
        Invoke-ProcessTDO - Start-Process wrapper that runs 'MSU|MSI|MSP|EXE' etc files with command line parameters, and returns Exitcode (and captured stdOut/stdErr, with -Passthru parameter)
        .INPUTS
        None. Does not accepted piped input.(.NET types, can add description)
        .OUTPUTS
        None. Returns no objects or output (.NET types)
        System.Boolean
        [| get-member the output to see what .NET obj TypeName is returned, to use here]
        .EXAMPLE
        PS> Invoke-ProcessTDO -whatif -verbose
        EXSAMPLEOUTPUT
        Run with whatif & verbose
        .EXAMPLE
        PS> Invoke-ProcessTDO
        EXSAMPLEOUTPUT
        EXDESCRIPTION
        .LINK
        https://github.com/tostka/verb-dev
        .LINK
        https://github.com/tostka/powershellbb/
        .PARAMETER FilePath
        Parent directory path containing target .msu|.msi|.msp|.exe etc [-FilePath c:\pathto\]
        .PARAMETER FileName
        Filename of target .msu|.msi|.msp|.exe etc [-FileName 'some.exe']
        .PARAMETER ArgumentList
        Array of arguments to used with target file [-ArgumentList @('/mode:RecoverServer', '/DoNotStartTransport', '/InstallWindowsComponents')]
        .PARAMETER PassThru
        Switch parameter to capture and return output & StdErr (rather than ErrorCode returned)
        .PARAMETER Silent
        Switch parameter to suppress all output but StdErr        
        .EXAMPLE
        PS> $Params= '/mode:RecoverServer', $State['IAcceptSwitch'], '/DoNotStartTransport', '/InstallWindowsComponents'
        PS> $Params+= "/TargetDir:`"$($State['TargetPath'])`""
        PS> $res= Invoke-ProcessTDO $State['SourcePath'] 'setup.exe' $Params
        PS> If( $res -ne 0 -or -not( Get-ItemProperty -Path $PresenceKey -Name InstallDate -ErrorAction SilentlyContinue)){
        PS>     Write-MyError 'Exchange Setup exited with non-zero value or Install info missing from registry: Please consult the Exchange setup log, i.e. C:\ExchangeSetupLogs\ExchangeSetup.log'
        PS>     Exit $ERR_PROBLEMEXCHANGESETUP
        PS> }
        Demo running an Exchange Setup.exe pass.
        .EXAMPLE
        PS> $RunFrom= Split-Path -Path $OnlineURL -Parent
        PS> Write-MyVerbose "Will run $FileName straight from $RunFrom"
        PS> Write-MyOutput "Installing $Package from $RunFrom"
        PS> $rval= Invoke-ProcessTDO $RunFrom $FileName $Arguments
        Demos executing a URL to run a package from download
        .EXAMPLE
        PS> $xCopyEXE = (get-command xcopy.exe -EA STOP).source ; 
        PS> write-verbose "Params below specify: /D: copy newer files only; /Y: suppress overrwrite prompt; /F echoes full source & dest path while copying
        PS> $xCopyParams= @('/D','/Y','/F') ; 
        PS> $sourceFile = (Join-Path $sourceDir $fileName )
        PS> $destFile = (Join-Path $destDir $fileName ) ;
        PS> $Params = @() ; 
        PS> $Params = @($sQot + $sourceFile + $sQot) ;
        PS> write-verbose "xcopy foible: prompts 'directory or file?', unless destination file spec ends in '*' char" ;      
        PS> $Params += @($sQot + "$($destFile)*" + $sQot) ; 
        PS> $Params = $(@($Params);@($xCopyParams)) ; 
        PS> if($whatif){$Params += @('/L')} ; 
        PS> $res= Invoke-ProcessTDO -FilePath (split-path $xCopyEXE) -FileName (split-path $xCopyEXE -Leaf) -ArgumentList $Params -PassThru; 
        PS> if($res.stdOut -match "0\sFile\(s\)"){
        PS>     $smsg = "(ExitCode:$($res.exitCode): no-updated copy:$($sourceFile):stdOut: $($res.stdOut))" ;
        PS>     write-verbose $smsg ;
        PS> } else {
        PS>     $smsg = "ExitCode:$($res.exitCode): UPDATED COPY: $($sourceFile) => $($destFile):stdOut: $($res.stdOut)" ;
        PS>     write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" 
        PS> } ; 
        PS> if($res.StdErr){
        PS>     $smsg = "A StandardError output was returned:`nSTDERR:$($res.StdErr)" ;
        PS>     write-WARNING $smsg ; 
        PS> } ; 
        Demo using this to execute an xcopy copy process and return results 
        #>
        [CmdletBinding()]
        [Alias('Invoke-Process')]
        PARAM(
                [Parameter(HelpMessage="Parent directory path containing target .msu|.msi|.msp|.exe etc [-FilePath c:\pathto\]")]
                    $FilePath,
                [Parameter(HelpMessage="Filename of target .msu|.msi|.msp|.exe etc [-FileName 'some.exe']")]
                    $FileName,
                [Parameter(HelpMessage="Array of arguments to used with target file [-ArgumentList @('/mode:RecoverServer', '/DoNotStartTransport', '/InstallWindowsComponents')]")]
                    $ArgumentList,
                [Parameter(HelpMessage="Switch parameter to capture and return output & StdErr (rather than ErrorCode returned)")]
                    [switch]$PassThru,
                [Parameter(HelpMessage="Switch parameter to suppress all output but StdErr")]
                    [switch]$Silent
        )
        $rval= 0
        $FullName= Join-Path $FilePath $FileName
        If( Test-Path $FullName) {
            Switch( ([io.fileinfo]$Filename).extension.ToUpper()) {
                '.MSU' {
                    $ArgumentList+= @( $FullName)
                    $ArgumentList+= @( '/f')
                    $Cmd= "$env:SystemRoot\System32\WUSA.EXE"
                }
                '.MSI' {
                    $ArgumentList+= @( '/i')
                    $ArgumentList+= @( $FullName)
                    $Cmd= "MSIEXEC.EXE"
                }
                '.MSP' {
                    $ArgumentList+= @( '/update')
                    $ArgumentList+= @( $FullName)
                    $Cmd= 'MSIEXEC.EXE'
                }
                default {
                    $Cmd= $FullName
                }
            }
            $smsg = "Executing $Cmd $($ArgumentList -Join ' ')"
            if($Silent){}elseif(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
            if($PassThru){
                $soutf= [System.IO.Path]::GetTempFileName()
                $serrf= [System.IO.Path]::GetTempFileName() 
                #$process = Start-Process -FilePath $Cmd -ArgumentList $ArgumentList -NoNewWindow -PassThru -Wait  -RedirectStandardOutput $soutf -RedirectStandardError $serrf  ; 
                # 2:21 PM 8/15/2025 getting popups even with -noNewWindow, reportedly bug with redirect use, shift to -WindowStyle Hidden as a workaround (offscreen)                
                $process = Start-Process -FilePath $Cmd -ArgumentList $ArgumentList -WindowStyle Hidden -PassThru -Wait  -RedirectStandardOutput $soutf -RedirectStandardError $serrf  ; 
                $oRet = [ordered]@{
                    handle = $process.handle 
                    ExitCode = $process.ExitCode ; 
                    StdOut = $null ; 
                    StdErr = $null ; 
                } ; 
                if((get-childitem $soutf).length) { 
                    $oRet.stdOut = (gc $soutf) | out-string ; 
                    remove-item $soutf ;
                } ;
                if((get-childitem $serrf).length) { 
                    $oRet.StdErr = (gc $serrf) | out-string ; 
                    remove-item $serrf ;
                } ;
                $smsg = "Process exited with code $($oRet.ExitCode)" ; 
                if($Silent){}elseif(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ;                         
                $rval = $oRet ; 
            }else{
                $rval=( Start-Process -FilePath $Cmd -ArgumentList $ArgumentList -NoNewWindow -PassThru -Wait).Exitcode
                $smsg = "Process exited with code $rval"
                if($Silent){}elseif(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ; 
                #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success       
            } ; 
            if($Silent){}elseif(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
            } ;
        } Else {
            $smsg = "$FullName not found"
            if(gcm Write-MyWarning -ea 0){Write-MyWarning $smsg } else {
                if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent}
                else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
            } ;
            $rval= -1
        }
        switch ($rval.gettype().fullname){
            'System.Int32'{
                return $rval
            }
            'System.String'{
                return $rval
            }
            'System.Collections.Specialized.OrderedDictionary'{
                return [pscustomobject]$rval 
            }
        }
    }

#*------^ Invoke-ProcessTDO.ps1 ^------


#*------v invoke-SpeakWords.ps1 v------
function invoke-speakwords {
    <#
    .SYNOPSIS
    invoke-speakwords - Text2Speech specified words
    .NOTES
    Author: Karl Prosser
    Website:	http://poshcode.org/835
    REVISIONS   :
    * 11:20 AM 12/9/2022 it's dumping a 1 into the pipeline, eat the output of $voice.speak; added cmdletbinding & moved alias into the body, instead of post-block; rename compliant verb: speak-words -> invoke-speakwords, alias speak-words
    * 2:02 PM 4/9/2015 - added to profile
    .PARAMETER  words
    Words or phrases to be spoken
    .PARAMETER  pause
    switch indicating whether to hold execution during speaking
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    invoke-speakwords "here we go now"  ;
    .EXAMPLE
    invoke-speakwords "$([datetime]::now)" ;
    Speak current date and time
    .EXAMPLE
    get-fortune | invoke-speakwords ;
    Speak output of get-fortune
    .LINK
    http://poshcode.org/835
    #>
    [CmdletBinding()]
    [Alias('speak-words','speak')]
    PARAM(
        [Parameter(Position = 0, Mandatory = $True, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true, HelpMessage = "Specify text to speak")]
        [ValidateNotNullOrEmpty()]
        [string]$words
        ,
        [Parameter(Position = 1, Mandatory = $False, HelpMessage = "Specify to wait for text to finish speaking")]
        [switch]$pause = $true
    ) # PARAM BLOCK END
    # default to no-pause, unless specified
    $flag = 1 ; if ($pause) { $flag = 2 }  ;
    $voice = new-Object -com SAPI.spvoice ;
    $voice.speak($words, [int] $flag) | out-null ; # 2 means wait until speaking is finished to continue

}

#*------^ invoke-SpeakWords.ps1 ^------


#*------v Move-Window.ps1 v------
function Move-Window {
    PARAM ($Handle, [int]$X, [int]$Y, [int]$Width, [int]$Height);
    process {[void][MoveWindowUtil.MoveWindowUtil]::MoveWindow($Handle, $X, $Y, $Width, $Height, $true);} 
}

#*------^ Move-Window.ps1 ^------


#*------v Move-WindowByWindowTitle.ps1 v------
function Move-WindowByWindowTitle {
    PARAM (
        [string]$ProcessName,
        [string]$WindowTitleRegex,
        [int]$X, [int]$Y, [int]$Width, [int]$Height)
    process {
        $procs = Get-Process -Name $ProcessName | Where-Object { $_.MainWindowTitle -match $WindowTitleRegex } ;
        foreach ($proc in $procs) {Move-Window -Handle $proc.MainWindowHandle -X $X -Y $Y -Width $Width -Height $Height}  ; 
    } 
}

#*------^ Move-WindowByWindowTitle.ps1 ^------


#*------v New-WallpaperStatusTDO.ps1 v------
Function New-WallpaperStatusTDO {
        <# 
        .SYNOPSIS
        New-WallpaperStatusTDO - Create desktop wallpaper with specified text overlaid over specified image or background color (PS Bginfo.exe alternative)
        .NOTES
        Version     : 1.0.4
        Author      : Todd Kadrie
        Website     :	http://www.toddomation.com
        Twitter     :	@tostka / http://twitter.com/tostka
        CreatedDate : 2020-06-27
        FileName    : New-WallpaperStatusTDO.ps1
        License     : (none asserted)
        Copyright   : (none asserted)
        Github      : https://github.com/tostka/verb-Desktop
        Tags        : Powershell
        AddedCredit : _Emin_
        AddedWebsite:	https://p0w3rsh3ll.wordpress.com/
        AddedTwitter:	URL
        REVISIONS   :
        * 4:08 PM 9/3/2025 update name to new tagged standard: ren Set-Wallpaper => Set-WallpaperTDO (alias orig name)
        # 10:46 AM 7/29/2021 ren'd New-BGinfo -> New-WallpaperStatus (stuck orig in Alias); added updated Win10 PS console color scheme colors to themes list (they're precurated 'suitable' colors) ; 
            added $FS3 3rd size, revised FS1 (+1 point of -FontSize), FS2 (-1); added verbose support & echos ; revised CBH (expanded Notes tags)
        # 11:42 AM 7/28/2021 added Violet & Yellow themes, test for $env:userdomain -like '*lab*' to set violet, expanded CBH example
        # # 8:51 AM 6/28/2016 fixed ampm -uformat
        # 11:14 AM 6/27/2016: added get-LocalDiskFreeSpace, local-only version (for BGInfo) drops server specs and reporting, and sorts on Name/driveletter
        # 1:43 PM 6/27/2016 ln159 psv2 is crapping out here, Primary needs to be tested $primary -eq $true for psv2
        # 12:29 PM 6/27/2016 params Psv2 Mandatory requires =$true
        # 12:21 PM 6/27/2016 submain: BGInfo: switch font to courier new
        # 11:27 AM 6/27/2016  submain: switched AMPM fmt to T
        # 11:24 AM 6/27/2016  submain: added | out-string | out-default to the drive info
        # 11:23 AM 6/27/2016 submain: added timestamp and drivespace report
        * 11:00 AM 6/27/2016 extended to accommodate & detect and redadmin the exchangeadmin acct as well
        * 10:56 AM 6/27/2016 reflects additions (Current theme)from cemaphore's comments & sample @ http://pastebin.com/Fva47UKT
		    along with the Red Admin Theme I added, and code to detect ucadmin/exchangeadmin 
		    # 10:48 AM 6/27/2016 tweak the uptime fmt:
        * 9:12 AM 6/27/2016 TSK reformatted, added pshelp
        * September 5, 2014 - posted version
        .DESCRIPTION
        New-WallpaperStatusTDO - Create desktop wallpaper with specified text overlaid over specified image or background color (PS Bginfo.exe alternative)
        .PARAMETER  Text
        Text to be overlayed over specified background
        .PARAMETER  OutFile
        Output file to be created (and then assigned separately to the desktop). Defaults to c:\temp\BGInfo.bmp
        .PARAMETER  Align
        Text alignment [Left|Center]
        .PARAMETER  Theme
        Desktop Color theme (defaults Current [Current|BrightBlue|Blue|DarkBlue|DarkWhite|Grey|LightGrey|BrightBlack|Black|BrightRed|Red|DarkRed|Purple|BrightYellow|Yellow|DarkYellow|BrightGreen|DarkGreen|BrightCyan|DarkCyan|BrightMagenta|DarkMagenta])[-Theme Red]
        .PARAMETER  FontName
        Text Font Name (Defaults Arial) [-FontName Arial]
        .PARAMETER  FontSize
        Integer Text Font Size (Defaults 12 point) [9-45]
        .PARAMETER  UseCurrentWallpaperAsSource
        Switch Param that specifies to recycle existing wallpaper [-UseCurrentWallpaperAsSource]
        .INPUTS
        None. Does not accepted piped input.
        .OUTPUTS
        None. Returns no objects or output.        
        .EXAMPLE
        PS> $BGInfo = @{
        PS>     Text  = $t ;
        PS>     Theme = "Black" ;
        PS>     FontName = "courier new" ;
        PS>     UseCurrentWallpaperAsSource = $false ;
        PS> } ; 
        PS> $WallPaper = New-WallpaperStatusTDO @BGInfo ;
        Generate a wallpaper from  a splat of parameters        
        .LINK
        https://p0w3rsh3ll.wordpress.com/2014/08/29/poc-tatoo-the-background-of-your-virtual-machines/
        .LINK
        https://github.com/tostka/verb-Desktop
        #>
        [CmdletBinding()]
        [Alias('New-BGinfo','New-WallpaperStatus')]
        Param(
            [Parameter(Mandatory=$true,HelpMessage="Text to be overlayed over specified background[-text 'line1`nline2']")]
                [string] $Text,
            [Parameter(HelpMessage="Output file to be created (and then assigned separately to the desktop). Defaults to c:\temp\BGInfo.bmp[-OutFile c:\path-to\image.jpg]")]
                [string] $OutFile= "$($($env:temp))\BGInfo.bmp",
            [Parameter(HelpMessage="Text alignment [Left|Center][-Align Left]")]
                [ValidateSet("Left","Center")]
                [string]$Align="Center",
            [Parameter(HelpMessage="Desktop Color theme (defaults Current [Current|BrightBlue|Blue|DarkBlue|DarkWhite|Grey|LightGrey|BrightBlack|Black|BrightRed|Red|DarkRed|Purple|BrightYellow|Yellow|DarkYellow|BrightGreen|DarkGreen|BrightCyan|DarkCyan|BrightMagenta|DarkMagenta])[-Theme Red]")]
                [ValidateSet("Current","BrightBlue","Blue","DarkBlue","DarkWhite","Grey","LightGrey","BrightBlack","Black","BrightRed","Red","DarkRed","Purple","BrightYellow","Yellow","DarkYellow","BrightGreen","DarkGreen","BrightCyan","DarkCyan","BrightMagenta","DarkMagenta")]
                [string]$Theme="Current",
            [Parameter(HelpMessage="Text Font Name (Defaults Arial) [-FontName 'courier new']")]
                [string]$FontName="Arial",
            [Parameter(HelpMessage="Integer Text Font Size (Defaults 8 point) [9-45][-FontSize 12]")]
                [ValidateRange(9,45)]
                [int32]$FontSize = 8,
            [Parameter(HelpMessage="Switch Param that specifies to recycle existing wallpaper [-UseCurrentWallpaperAsSource]")]
                [switch]$UseCurrentWallpaperAsSource
        ) ; 
        BEGIN {
            $verbose = ($VerbosePreference -eq "Continue") ; 
            # 9:59 AM 6/27/2016 add cmaphore's detection of Current Theme
            # Enumerate current wallpaper now, so we can decide whether it's a solid colour or not
            try {
                $wpath = (Get-ItemProperty 'HKCU:\Control Panel\Desktop' -Name WallPaper -ErrorAction Stop).WallPaper
                if ($wpath.Length -eq 0) {
                    # Solid colour used
                    $UseCurrentWallpaperAsSource = $false ; 
                    $Theme = "Current" ; 
                } ; 
            } catch {
                $UseCurrentWallpaperAsSource = $false ; 
                $Theme = "Current" ; 
            } ; 
            # standardize colors (for easy uese in font colors as well as bg) - lifted many of these from updated Powershell console color scheme specs.
            $cBrightBlue = @(59,120,255) ;
            $cBlue = @(58,110,165) ; # default win desktop blue
            $cDarkBlue = @(0,55,218) ; 
            $cDarkWhite = @(204,204,204) ; 
            $cGrey = @(77,77,77) ; 
            $cLightGrey = @(176,176,176) ; 
            $cBrightBlack = @(118,118,118) ; 
            $cBlack = @(12,12,12) ; 
            $cBrightRed = @(231,72,86) ; 
            $cRed = @(184,40,50) ; 
            $cDarkRed = @(197,15,31) ; 
            $cPurple = @(192,32,214) ; 
            $cBrightYellow = @(249,241,165) ; 
            $cYellow = @(255,185,0) ; 
            $cDarkYellow = @(193,156,0) ; 
            $cBrightGreen = @(22,198,12) ; 
            $cDarkGreen = @(19,161,14) ; 
            $cBrightCyan = @(97,214,214) ; 
            $cDarkCyan = @(58,150,221) ; 
            $cBrightMagenta = @(180,0,158) ; 
            $cDarkMagenta = @(136,23,152) ; 
            $cWhite = @(242,242,242) ;
            $cDefaultWhite = @(254,253,254) ; 
            $cMedGrey = @(185,190,188) ; 
        
        
            Switch ($Theme) {
                # revised the stock colors to reflect PSConsole's revised color scheme [Updating the Windows Console Colors | Windows Command Line - devblogs.microsoft.com/](https://devblogs.microsoft.com/commandline/updating-the-windows-console-colors/)
                # 9:42 AM 6/27/2016 add cmaphore's idea of a 'Current' theme switch case, pulling current background color $RGB, and defaulting if not set
                # $FC1 is used for the first line of any text ; $FC2 is used for the remaining lines of text
                Current {
                    $RGB = (Get-ItemProperty 'HKCU:\Control Panel\Colors' -ErrorAction Stop).BackGround ; 
                    if ($RGB.Length -eq 0) {
                        $Theme = "Black" ; # Default to Black and don't break the switch
                    } else {
                        $BG = $RGB -split " " ; 
                        $FC1 = $FC2 = $cWhite ; 
                        $FS1=$FS2=$FontSize ; 
                        break ; 
                    } ; 
                } ; 
                BrightBlue { 
                    $BG = $cBlue ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cMedGrey ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                    break ; 
                } ; 
                Blue { # default win desktop blue 
                    $BG = $cBlue ; 
                    $FC1 = $cDefaultWhite ; 
                    $FC2 = $cMedGrey ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                    break ; 
                } ; 
                DarkBlue { # 
                    $BG = $cDarkBlue ; 
                    $FC1 = $cDefaultWhite ; 
                    $FC2 = $cMedGrey ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                    break ; 
                } ; 
                DarkWhite {
                    $BG = $cDarkWhite ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cBlack ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                    break ; 
                } ; 
                Grey {
                    $BG = $cGrey ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                    break ; 
                } ; 
                LightGrey {
                    $BG = $cLightGrey ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cBlack ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                    break ; 
                } ; 
                BrightBlack {
                    $BG = $cBrightBlack; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite  ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                Black {
                    $BG = $cBlack ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                BrightRed {
                    $BG = $cBrightRed ; 
                    $FC1 = $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                Red {
                    $BG = $cRed ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                DarkRed {
                    $BG = $cDarkRed ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                Purple {
                    $BG = $cPurple ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                BrightYellow {
                    $BG = $cBrightYellow ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                Yellow {
                    $BG = $cYellow ; 
                    $FC1 = $cDarkBlue ; 
                    $FC2 = $cBlack ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                DarkYellow {
                    $BG = $cDarkYellow ; 
                    $FC1 = $cDarkBlue ; 
                    $FC2 = $cBlack ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                BrightGreen {
                    $BG = $cBrightGreen ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                DarkGreen {
                    $BG = $cDarkGreen ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                BrightCyan {
                    $BG = $cBrightCyan ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                DarkCyan {
                    $BG = $cDarkCyan ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                BrightMagenta {
                    $BG = $cBrightMagenta ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
                DarkMagenta {
                    $BG = $cDarkMagenta ; 
                    $FC1 = $cYellow ; 
                    $FC2 = $cWhite ; 
                    $FS1 = $FontSize+1 ; 
                    $FS2 = $FontSize-1 ; 
                    $FS3 = $FontSize-2 ; 
                } ; 
            } ;  # swtch-E
          
            Try {
                [system.reflection.assembly]::loadWithPartialName('system.drawing.imaging') | out-null ; 
                [system.reflection.assembly]::loadWithPartialName('system.windows.forms') | out-null ; 
                # Draw string > alignement
                $sFormat = new-object system.drawing.stringformat
                Switch ($Align) {
                    Center {
                        $sFormat.Alignment = [system.drawing.StringAlignment]::Center ; 
                        $sFormat.LineAlignment = [system.drawing.StringAlignment]::Center ; 
                        break ; 
                    } ; 
                    Left {
                        $sFormat.Alignment = [system.drawing.StringAlignment]::Center ; 
                        $sFormat.LineAlignment = [system.drawing.StringAlignment]::Near ; 
                    } ; 
                } ;  
     
                if ($UseCurrentWallpaperAsSource) {
                    # 10:01 AM 6/27/2016 moved $wppath to top of begin
                    if (Test-Path -Path $wpath -PathType Leaf) {
                        $bmp = new-object system.drawing.bitmap -ArgumentList $wpath ; 
                        $image = [System.Drawing.Graphics]::FromImage($bmp) ; 
                        $SR = $bmp | Select Width,Height ; 
                    } else {
                        Write-Warning -Message "Failed cannot find the current wallpaper $($wpath)" ; 
                        break ; 
                    } ; 
                } else {
                    # 1:43 PM 6/27/2016 psv2 is crapping out here, Primary needs to be tested $primary -eq $true for psv2
                    #$SR = [System.Windows.Forms.Screen]::AllScreens | Where Primary | Select -ExpandProperty Bounds | Select Width,Height ; 
                    $SR = [System.Windows.Forms.Screen]::AllScreens |?{$_.Primary} | Select -ExpandProperty Bounds | Select Width,Height ; 
                    #}
                    Write-Verbose -Message "Screen resolution is set to $($SR.Width)x$($SR.Height)" -Verbose ; 
     
                    # Create Bitmap
                    $bmp = new-object system.drawing.bitmap($SR.Width,$SR.Height) ; 
                    $image = [System.Drawing.Graphics]::FromImage($bmp) ; 
         
                    $image.FillRectangle(
                        (New-Object Drawing.SolidBrush (
                            [System.Drawing.Color]::FromArgb($BG[0],$BG[1],$BG[2]) 
                        )),
                        (new-object system.drawing.rectanglef(0,0,($SR.Width),($SR.Height))) 
                    ) ; 
                } ; 
            
            } Catch {
                Write-Warning -Message "Failed to $($_.Exception.Message)" ; 
                break ; 
            } ; 
        } ;  # BEG-E
        PROCESS {
            # Split our string as it can be multiline
            $artext = ($text -split "\r\n") ; 
            $i = 1 ; 
            Try {
                for ($i ; $i -le $artext.Count ; $i++) {
                    if ($i -eq 1) {
                        $font1 = New-Object System.Drawing.Font($FontName,$FS1,[System.Drawing.FontStyle]::Bold) ; 
                        $Brush1 = New-Object Drawing.SolidBrush (
                            [System.Drawing.Color]::FromArgb($FC1[0],$FC1[1],$FC1[2]) 
                        ) ; 
                        $sz1 = [system.windows.forms.textrenderer]::MeasureText($artext[$i-1], $font1) ; 
                        $rect1 = New-Object System.Drawing.RectangleF (0,($sz1.Height),$SR.Width,$SR.Height) ; 
                        $image.DrawString($artext[$i-1], $font1, $brush1, $rect1, $sFormat) ; 
                    } elseif ($i -eq 2) {
                        $font2 = New-Object System.Drawing.Font($FontName,$FS2,[System.Drawing.FontStyle]::Bold) ; 
                        $Brush2 = New-Object Drawing.SolidBrush (
                            [System.Drawing.Color]::FromArgb($FC2[0],$FC2[1],$FC2[2]) 
                        ) ; 
                        $sz2 = [system.windows.forms.textrenderer]::MeasureText($artext[$i-1], $font2) ; 
                        $rect2 = New-Object System.Drawing.RectangleF (0,($i*$FontSize*2 + $sz2.Height),$SR.Width,$SR.Height) ; 
                        $image.DrawString($artext[$i-1], $font2, $brush2, $rect2, $sFormat) ; 
                    } else {
                        $font3 = New-Object System.Drawing.Font($FontName,$FS3,[System.Drawing.FontStyle]::Bold) ; 
                        $Brush3 = New-Object Drawing.SolidBrush (
                            [System.Drawing.Color]::FromArgb($FC2[0],$FC2[1],$FC2[2]) 
                        ) ; 
                        $sz3 = [system.windows.forms.textrenderer]::MeasureText($artext[$i-1], $font2) ; 
                        $rect3 = New-Object System.Drawing.RectangleF (0,($i*$FontSize*2 + $sz3.Height),$SR.Width,$SR.Height) ; 
                        $image.DrawString($artext[$i-1], $font3, $Brush3, $rect3, $sFormat) ; 
                    } ; 
                } ;  # loop-E
            
            } Catch {
                Write-Warning -Message "Failed to $($_.Exception.Message)" ; 
                break ; 
            } ; 
        
        } ;  # PROC-E
        END {  
            Try {
                # Close Graphics
                $image.Dispose(); ; 
     
                # Save and close Bitmap
                $bmp.Save($OutFile, [system.drawing.imaging.imageformat]::Bmp); ; 
                $bmp.Dispose() ;      
                # Output our file path into the pipeline
                Get-Item -Path $OutFile | write-output ; 
            } Catch {
                Write-Warning -Message "Failed to $($_.Exception.Message)" ; 
                break ; 
            } ; 
        } ;  # END-E
    }

#*------^ New-WallpaperStatusTDO.ps1 ^------


#*------v Report-URL.ps1 v------
function Report-URL {
    <#
    .SYNOPSIS
    Report-URL.ps1 - Resolves url into "[Title] - [url]" summary string, and copies to clipboard - also expands shortened uri's to full target.
    .NOTES
    Author: Todd Kadrie
    Website:	http://www.toddomation.com
    Twitter:	@tostka, http://twitter.com/tostka
    Additional Credits: Todd O. Klindt Resolve Short URLs with PowerShell - Todd Klindt's Office 365 Admin Blog
    Website:	https://www.toddklindt.com/blog/Lists/Posts/Post.aspx?ID=764
    REVISIONS   :
    * 8:05 AM 12/13/2019 Report-URL:added -md & -title, added formal param block, switched from dumps to explicit write-ouput
    * 1:44 PM 1/23/2019 init vers
    .DESCRIPTION
    Defaults to PM Copy Page Title & Location As, Plain text, output:
    -md triggers output in Markdown link format:
    [Base64 Encoding of Images via Powershell | LINQ to Fail](https://www.aaron-powell.com/posts/2010-11-07-base64-encoding-images-with-powershell/)
    .PARAMETER  Url
    Internet URL to be resolved
    .PARAMETER  md
    Output Markdown switch [-md]
    .PARAMETER title
    Output Title-only switch[-md]
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    Dumps info to console, and copies to clipboard
    .EXAMPLE
    report-url https://www.google.com ;
    returns: Google - https://www.google.com/
    .EXAMPLE
    .LINK
    #>
    PARAM(
        [Parameter(Position=0,Mandatory=$True,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,HelpMessage="Internet URL to be resolved[-url https://xxxxx]")]
        [ValidateNotNullOrEmpty()]$Url,
        [Parameter(HelpMessage="Output Markdown switch [-md]")]
        [switch] $md,
        [Parameter(HelpMessage="Output Title-only switch[-md]")]
        [switch] $title,
        [Parameter(HelpMessage="Debugging Flag [-showDebug]")]
        [switch] $showDebug,
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf=$true
    ) ;
    $error.clear() ;
    TRY {
        $page=Invoke-WebRequest -Uri $url ;
        if($title) {
            $rpt = "$(($page.parsedhtml.title|out-string).trim())" ;
        } elseif($md){
            $rpt = "[$(($page.parsedhtml.title|out-string).trim())]($(($page.baseresponse.ResponseUri.AbsoluteUri |out-string).trim()))" ;
        } else {
            $rpt="$(($page.parsedhtml.title|out-string).trim()) - $(($page.baseresponse.ResponseUri.AbsoluteUri |out-string).trim())" ;
        } ;
        $rpt | write-output ;
        write-verbose -verbose:$true "(copied to CB)" ;
        $rpt | out-clipboard ;
    } CATCH {
        Write-Error "$(get-date -format 'HH:mm:ss'): Failed processing $($_.Exception.ItemName). `nError Message: $($_.Exception.Message)`nError Details: $($_)" ;
        Exit ;
    } ;

} ; #*------^ END Function Report-URL ^------
If (!(Test-Path ALIAS:Rpt-URL)) { new-Alias -Name Rpt-URL -Value report-url}

#*------^ Report-URL.ps1 ^------


#*------v Reset-CurrentWallpaperTDO.ps1 v------
Function Reset-CurrentWallpaperTDO {
        <#
        .SYNOPSIS
        Reset-CurrentWallpaperTDO - Tests for, and clears any configured HKCU:\Control Panel\Desktop WallPaper Value to $NULL, and refreshes the desktop
        .NOTES
        Version     : 1.0.0
        Author      : Todd Kadrie
        Website     :	http://www.toddomation.com
        Twitter     :	@tostka / http://twitter.com/tostka
        CreatedDate : 2025-07-30
        FileName    : Reset-CurrentWallpaperTDO.ps1
        License     : MIT License
        Copyright   : (c) 2025 Todd Kadrie
        Github      : https://github.com/tostka/verb-io
        Tags        : Powershell,Math,Round,Ceiling,Floor,Truncate,Number,Decimal
        AddedCredit : REFERENCE
        AddedWebsite:	URL
        AddedTwitter:	URL
        REVISIONS
        * 11:17 AM 9/29/2025 CBH: corrected output spec to None.
        * 4:06 PM 9/3/2025 init
        .DESCRIPTION
        Reset-CurrentWallpaperTDO - Tests for, and clears any configured HKCU:\Control Panel\Desktop WallPaper Value to $NULL, and refreshes the desktop
        .OUTPUT
        None
        .EXAMPLE
        PS> Reset-CurrentWallpaperTDO 
        Demo call
        .LINK
        https://github.com/tostka/verb-desktop
        #>
        PARAM()
        PROCESS{
            $CurrentWallPaperValue = (Get-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name "WallPaper").WallPaper ; 
            if($CurrentWallPaperValue){
                $smsg = "HKCU:\Control Panel\Desktop\ WallPaper Value is currently set to: $($CurrentWallPaperValue)" ;
                if(test-path -path $CurrentWallPaperValue -PathType Leaf){
                    $smsg += "`n(which exists)" ;                    
                } else{
                    $smsg += "`n(which does not exist)" ;
                }; 
                $smsg += "`nClearing the value..." ;
                if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                } ;
                Set-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name "WallPaper" -Value $NULL -verbose ; 
                $CurrentWallPaperValue = (Get-ItemProperty -Path "HKCU:\Control Panel\Desktop" -Name "WallPaper").WallPaper ; 
                $smsg = "HKCU:\Control Panel\Desktop\ WallPaper value is now set: $($CurrentWallPaperValue)" ;
                $smsg += "`nIssuing desktop reset:rundll32.exe user32.dll, UpdatePerUserSystemParameters..." ;
                if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;              
                } ;
                rundll32.exe user32.dll, UpdatePerUserSystemParameters ; 
            } else{
                $smsg = "HKCU:\Control Panel\Desktop\ WallPaper Value is currently UNSET (NULL) (no change)" ; 
                if(gcm Write-MyOutput -ea 0){Write-MyOutput $smsg } else {
                    if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level H1 } else{ write-host -foregroundcolor green "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                    #Levels:Error|Warn|Info|H1|H2|H3|H4|H5|Debug|Verbose|Prompt|Success
                } ;
            } ; 
        }
    }

#*------^ Reset-CurrentWallpaperTDO.ps1 ^------


#*------v restart-Shell.ps1 v------
function restart-Shell {
    <#
    .SYNOPSIS
    restart-Shell - Close and restart windows'shell'/desktop explorer process
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2020-05-01
    FileName    : restart-Shell
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell,Registry,Maintenance
    REVISIONS
    * 2:12 PM 2/21/2023 added legacy post-filter support (syntax); this is also in verb-io ; 
    * 12:55 PM 5/1/2020 init vers
    .DESCRIPTION
    restart-Shell - Close and restart windows'shell'/desktop explorer process
    Identifies 'Taskbar'/Shell explorer process, as the one with no MainWindowTitle. Using Ctrl+Shift+r-click Taskbar > Exit Windows is cleaner - propertly saves shell config changes. But this is a scriptable alt.
    .PARAMETER ShowDebug
    Parameter to display Debugging messages [-ShowDebug switch]
    .PARAMETER Whatif
    Parameter to run a Test no-change pass [-Whatif switch]
    .OUTPUT
    System.Object[]
    .EXAMPLE
    restart-Shell -Path 'HKCU:\Control Panel\Desktop' -Name 'AutoColorization' -Value 0
    Update the desktop AutoColorization property to the value 0
    .EXAMPLE
    restart-Shell
    Close and restart explorer shell
    .EXAMPLE
    restart-Shell -verbose -whatif
    Close and restart explorer shell with whatif and verbose output
    .LINK
    https://github.com/tostka
    #>
    [CmdletBinding()]
    Param(
        [Parameter(HelpMessage = "Debugging Flag [-showDebug]")]
        [switch] $showDebug,
        [Parameter(HelpMessage = "Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) ;
    ${CmdletName} = $PSCmdlet.MyInvocation.MyCommand.Name ;
    $PSParameters = New-Object -TypeName PSObject -Property $PSBoundParameters ;
    $Verbose = ($VerbosePreference -eq 'Continue') ;
    $error.clear() ;
    TRY {
        Get-Process explorer | ?{$_.MainWindowTitle -eq ''} | stop-process -Force -whatif:$($whatif);
        sleep -sec 2 ;
        if (-not(Get-Process explorer | ?{$_.MainWindowTitle -eq ''} )) {
            # Only spawn a new explorer if a new 'shell' one didn't auto-load w/in 2secs (generally does on win10 ; avoids opening a spurious new explorer window)
            start explorer.exe ;
        } ;
        $true | write-output ;
    } CATCH {
        $ErrTrpd = $_ ;
        Write-Warning "$(get-date -format 'HH:mm:ss'): Failed processing $($ErrTrpd.Exception.ItemName). `nError Message: $($ErrTrpd.Exception.Message)`nError Details: $($ErrTrpd)" ;
        $false | write-output ;
    } ;
}

#*------^ restart-Shell.ps1 ^------


#*------v Set.ps1 v------
If (Test-Path ALIAS:set) { Remove-Item ALIAS:set } ;
Function Set {
    <#
    .SYNOPSIS
    Set() - Emulate the DOS Set e-vari-handling cmd in PS
    .NOTES
    Author: Bill Stewart
    Website:	http://windowsitpro.com/powershell/powershell-how-emulating-cmdexes-set-command
    REVISIONS   :
    * 6:53 AM 8/9/2016 minor comment typo fix
    * 8:42 AM 4/10/2015 reformatted, added help
    * Dec 12, 2011 posted
    .DESCRIPTION
    Note:  You can't use the Set function as part of a PowerShell expression, such as
    (Set processor_level).GetType()
    But it has two advantages over Cmd.exe's Set command. First, it outputs DictionaryEntry objects, just like when you use the command...
    Get-ChildItem ENV:
    Second, the Set function uses wildcard matching. For example, the command...
    Set P
    ...matches only a variable named P. Use Set P* to output all evari's beginning with P.
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    No formatting appears to have been put int, results are output to the pipeline.
    .EXAMPLE
    Set
    To list all of the current $env: (equiv to gci $env:)
    .LINK
    http://windowsitpro.com/powershell/powershell-how-emulating-cmdexes-set-command
    #>
    If (-Not $ARGS) {
        Get-ChildItem ENV: | Sort-Object Name ;
        Return ;
    } ;
    $myLine = $MYINVOCATION.Line ;
    $myName = $MYINVOCATION.InvocationName ;
    $myArgs = $myLine.Substring($myLine.IndexOf($myName) + $myName.Length + 1) ;
    $equalPos = $myArgs.IndexOf("=") ;
    # If the "=" character isn't found, output the variables.
    If ($equalPos -eq -1) {
        $result = Get-ChildItem ENV: | Where-Object { $_.Name -like "$myArgs" } |
        Sort-Object Name ;
        If ($result) { $result } Else { Throw "Environment variable not found" } ;
    }
    ElseIf ($equalPos -lt $myArgs.Length - 1) {
        # If the "=" character is found before the end of the string, set the variable.
        $varName = $myArgs.Substring(0, $equalPos) ;
        $varData = $myArgs.Substring($equalPos + 1) ;
        Set-Item ENV:$varName $varData ;
    }
    Else {
        # If the "=" character is found at the end of the string, remove the variable.
        $varName = $myArgs.Substring(0, $equalPos) ;
        If (Test-Path ENV:$varName) { Remove-Item ENV:$varName } ;
    } # if-E
}

#*------^ Set.ps1 ^------


#*------v Set-WallpaperTDO.ps1 v------
Function Set-WallpaperTDO {
        <# 
        .SYNOPSIS
        Set-WallpaperTDO - Set specified file as desktop wallpaper
        .NOTES
        Version     : 0.0.
        Author      : Todd Kadrie
        Website     : http://www.toddomation.com
        Twitter     : @tostka / http://twitter.com/tostka
        CreatedDate : 2016-06-27
        FileName    : Set-WallpaperTDO.ps1
        License     : MIT License
        Copyright   : (c) 2025 Todd Kadrie
        Github      : https://github.com/tostka/verb-desktop
        Tags        : Powershell,Wallpaper,Status
        AddedCredit : _Emin_
        AddedWebsite: https://p0w3rsh3ll.wordpress.com/2014/08/29/poc-tatoo-the-background-of-your-virtual-machines/
        AddedTwitter: URL
        REVISIONS   :
        * 11:13 AM 9/29/2025 rplc verb-noun -> Set-WallpaperTDO
        * 2:59 PM 9/4/2025 strongly type params, add parameter tags and helpmessage, update CBH
        * 4:08 PM 9/3/2025 update name to new tagged standard: ren Set-Wallpaper => Set-WallpaperTDO (alias orig name)
        * 9:12 AM 6/27/2016 TSK reformatted & added pshelp
        * September 5, 2014 - posted version
        .DESCRIPTION
        .PARAMETER  Path
        Path to image to be set as desktop backgroun[-Path c:\pathto\bg.bmp]
        .PARAMETER  Style
        Wallpaper image display style (Center|Stretch|Fill|Tile|Fit, default:Stretch)[-Style Fill]
        .INPUTS
        None. Does not accepted piped input.
        .OUTPUTS
        None. Returns no objects or output.
        .EXAMPLE
        PS> Set-WallpaperTDO -Path $WallPaper.FullName -Style Fill ;
        Set wallpaper file to fill screen
        .EXAMPLE
        PS> Set-Wallpaper -Path "C:\Windows\Web\Wallpaper\Windows\img0.jpg" -Style Fill ; 
        To Restore the default VM wallpaper (e.g. generally the Windows OS default)
        .LINK
        https://p0w3rsh3ll.wordpress.com/2014/08/29/poc-tatoo-the-background-of-your-virtual-machines/
        .LINK
        https://github.com/tostka/verb-desktop
        #>
        [CmdletBinding()]
        [Alias('Set-Wallpaper')]
        Param(
            [Parameter(Mandatory=$true,HelpMessage="Path to image to be set as desktop backgroun[-Path c:\pathto\bg.bmp]")]
                [ValidateScript({Test-Path $_ -pathtype Leaf})]
                [string]$Path,
            [Parameter(HelpMessage="Wallpaper image display style (Center|Stretch|Fill|Tile|Fit, default:Stretch)[-Style Fill]")]
                [ValidateSet('Center','Stretch','Fill','Tile','Fit')]
                [string]$Style = 'Stretch' 
        ) ; 
        $verbose = ($VerbosePreference -eq "Continue") ; 
        Try {
            if (-not ([System.Management.Automation.PSTypeName]'Wallpaper.Setter').Type) {
                Add-Type -TypeDefinition @"
           using System;
            using System.Runtime.InteropServices;
            using Microsoft.Win32;
            namespace Wallpaper {
                public enum Style : int {
                Center, Stretch, Fill, Fit, Tile
                }
                public class Setter {
                    public const int SetDesktopWallpaper = 20;
                    public const int UpdateIniFile = 0x01;
                    public const int SendWinIniChange = 0x02;
                    [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
                    private static extern int SystemParametersInfo (int uAction, int uParam, string lpvParam, int fuWinIni);
                    public static void SetWallpaper ( string path, Wallpaper.Style style ) {
                        SystemParametersInfo( SetDesktopWallpaper, 0, path, UpdateIniFile | SendWinIniChange );
                        RegistryKey key = Registry.CurrentUser.OpenSubKey("Control Panel\\Desktop", true);
                        switch( style ) {
                            case Style.Tile :
                                key.SetValue(@"WallpaperStyle", "0") ;
                                key.SetValue(@"TileWallpaper", "1") ;
                                break;
                            case Style.Center :
                                key.SetValue(@"WallpaperStyle", "0") ;
                                key.SetValue(@"TileWallpaper", "0") ;
                                break;
                            case Style.Stretch :
                                key.SetValue(@"WallpaperStyle", "2") ;
                                key.SetValue(@"TileWallpaper", "0") ;
                                break;
                            case Style.Fill :
                                key.SetValue(@"WallpaperStyle", "10") ;
                                key.SetValue(@"TileWallpaper", "0") ;
                                break;
                            case Style.Fit :
                                key.SetValue(@"WallpaperStyle", "6") ;
                                key.SetValue(@"TileWallpaper", "0") ;
                                break;
}
                        key.Close();
                    }
                }
            }
"@ -ErrorAction Stop ; 
                } else {
                    Write-Verbose -Message "Type already loaded" -Verbose ; 
                } ; 
            # } Catch TYPE_ALREADY_EXISTS
            } Catch {
                Write-Warning -Message "Failed because $($_.Exception.Message)" ; 
            } ; 
     
        [Wallpaper.Setter]::SetWallpaper( $Path, $Style ) ; 
    }

#*------^ Set-WallpaperTDO.ps1 ^------


#*------v show-TrayTip.ps1 v------
function show-TrayTip {
    <#
    .SYNOPSIS
    Show-TrayTip() - Display popup System Tray Tooltip
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 2020-
    FileName    :
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka
    Tags        : Powershell
    AddedCredit : Pat Richard (pat@innervation.com)
    AddedWebsite: http://www.ehloworld.com/1038
    AddedTwitter:
    REVISIONS
    * 2:23 PM 3/10/2016 reworked the $TrayIcon validation, to permit either a valid path to an .ico, or a variable of Icon type (of the type pulled from shell32.dll by Extract-Icon()); debugged and functional in check-kpconflict.ps1 ; added some concepts from the src Pat used: Dr. Tobias Weltner, http://www.powertheshell.com/balloontip/ (Pat was in the comments asking questions on the subject) ; added some concepts from Pat Richard http://www.ehloworld.com/1038
    * 11:19 AM 3/6/2016 - unknown original, updating with formatting, pshelp and updated params
    .DESCRIPTION
    Show-TrayTip() - Display popup System Tray Tooltip
    .PARAMETER Type
    Tip Icon type [Error|Info|Warning|None]
    .PARAMETER Text
    Tip Text to be displayed [string]
    .PARAMETER title
    Tip Title [string]
    .PARAMETER ShowTime
    Tip Display Time (secs, default:2)[int]
    .PARAMETER TrayIcon
    Specify variant Systray icon (defaults per type)
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    None. Returns no objects or output.
    .EXAMPLE
    show-TrayTip -type "error" -text "$computer is still ONLINE; Check that reboot is initiated properly" -title "Computer is not rebooting"
    Show TrayTip with default (powershell) Systray Icon, Error-type balloon icon, and balloon title & text specified, for 30 seconds
    .EXAMPLE
    show-TrayTip -type "error" -title "CONFLICT!" -text "CONFLICTED KEEPASS DB FOUND!" -ShowTime 30 -TrayIcon $TrayIcon ;
    Show TrayTip with custom Systray Icon, Error-type balloon icon, and balloon title & text specified, for 30 seconds
    .EXAMPLE
    show-TrayTip -type info -text "PowerShell script has finished processing" -title "Completed"
    Basic Example using parameter names (rest defaults)
    .EXAMPLE
    show-TrayTip info "PowerShell script has finished processing" "Completed"
    Basic Example using positional parameters
    .EXAMPLE
    if($script:TrayTip) { $script:TrayTip.Dispose() ; Remove-Variable -Scope script -Name TrayTip ; }
    Cleanup code that should be used at script-end to cleanup the objects
    .LINK
    #>
    [CmdletBinding(SupportsShouldProcess = $true)]
    Param(
        [Parameter(Position=0,Mandatory=$True,HelpMessage="Tip Icon type [Error|Info|Warning|None]")][ValidateSet("Error","Info","Warning","None")]
        [string]$Type
        ,[Parameter(Position=1,Mandatory=$True,HelpMessage="Tip Text to be displayed [string]")][ValidateNotNullOrEmpty()]
        [string]$Text
        ,[Parameter(Position=2,Mandatory=$True,HelpMessage="Tip Title [string]")]
        [string]$Title
        ,[Parameter(HelpMessage="Tip Display Time (secs, default:2)[int]")][ValidateRange(1,30)]
        [int]$ShowTime=2
        ,[parameter(HelpMessage = "Specify variant Systray icon (defaults to Powershell)")]
        $TrayIcon
    )  ;
    BEGIN {
        if($TrayIcon){
            if( (test-path $TrayIcon) -OR ($TrayIcon.gettype().name -eq 'Icon') ){ }
            else {
                write-warning "Invalid TrayIcon, resetting to Default Icon" ;
                $TrayIcon =$null ;
            } ;
        } ;
    } ;
    PROCESS {
        if(!($NoTray)){
            #load Windows Forms and drawing assemblies
            [reflection.assembly]::loadwithpartialname("System.Windows.Forms") | Out-Null ; # used for TrayTip tips
            [reflection.assembly]::loadwithpartialname("System.Drawing") | Out-Null ; # used for icon extraction
            #define an icon image pulled from PowerShell.exe
            #$icon=[system.drawing.icon]::ExtractAssociatedIcon((join-path $pshome powershell.exe)) ;
            # load the TrayTip
            if ($script:TrayTip -eq $null) {  $script:TrayTip = New-Object System.Windows.Forms.NotifyIcon } ;
            <# TrayIcon (BalloonTip): configurable property's:
              # the systray icon to be displayed (extracted from the PS path here)
              $path                    = Get-Process -id $pid | Select-Object -ExpandProperty Path ;
              $TrayTip.Icon            = [System.Drawing.Icon]::ExtractAssociatedIcon($path) ;
              # the following configure settings _within_ the balloon popup
              $TrayTip.BalloonTipIcon  = $Icon ;
              $TrayTip.BalloonTipText  = $Text ;
              $TrayTip.BalloonTipTitle = $Title ;
              # finally show the BalloonTip, with a specified timeout.
              $TrayTip.Visible         = $true ;
              $TrayTip.ShowBalloonTip($Timeout) ;
            #>
            if ($TrayIcon) { $TrayTip.Icon = $TrayIcon  }
            else {
                # use the extracted Powershell process icon
                $Path = Get-Process -id $pid | Select-Object -ExpandProperty Path ;
                $TrayTip.Icon = [System.Drawing.Icon]::ExtractAssociatedIcon($path) ;
            }
            $TrayTip.BalloonTipIcon  = $Type ;
            $TrayTip.BalloonTipText  = $Text ;
            $TrayTip.BalloonTipTitle = $Title ;
            $TrayTip.Visible         = $true ;
            # set timeout (in ms)
            $TrayTip.ShowBalloonTip($ShowTime*1000) ;
            write-verbose -verbose:$verbose "`$TrayTip:`n$(($TrayTip | fl * |out-string).trim())" ;
        } ;# if-E $NoTray ;
    } ;
    END {
        <# Cleanup code that should be used at script-end to cleanup the objects
            if($script:TrayTip) { $script:TrayTip.Dispose() ; Remove-Variable -Scope script -Name TrayTip ; }
        #>
    } ;
}

#*------^ show-TrayTip.ps1 ^------


#*------v start-ItunesPlaylist.ps1 v------
Function start-ItunesPlaylist {
    <#
    .SYNOPSIS
    Plays an iTunes playlist.
    .DESCRIPTION
    Opens the Apple iTunes application and starts playing the given iTunes playlist.
    .NOTES
    Author: Frank Peter (http://www.out-web.net/?p=1390)
    .PARAMETER  Source
    Identifies the name of the source.(["Library"|"Internet Radio"]
    .PARAMETER  Playlist
    Identifies the name of the playlist
    .PARAMETER  Shuffle
    Turns shuffle on (else don't care).
    .EXAMPLE
    C:\PS> .\Start-PlayList.ps1 -Source 'Library' -Playlist 'Party'
    .EXAMPLE
    C:\PS> .\Start-PlayList.ps1 -source 'Library' -Playlist "classical-streams"
    .INPUTS
    None
    .OUTPUTS
    None
    #>
    [CmdletBinding()]
    param (
        [Parameter(Mandatory = $true)]
        $Source,
        [Parameter(Mandatory = $true)]
        $Playlist,
        [Switch]$Shuffle
    ) ;
    try {$iTunes = New-Object -ComObject iTunes.Application
    }catch {Write-Error 'Download and install Apple iTunes'return} ;
    <# source options (interegated to get)
    Name
    ----
    Library
    Internet Radio
    #>
    $src = $iTunes.Sources | Where-Object { $_.Name -eq $Source } ;
    if (!$src) {
        Write-Error "Unknown source - $Source" ;
        return ;
    } ; # if-E
    $ply = $src.Playlists | Where-Object { $_.Name -eq $Playlist } ;
    if (!$ply) {
        Write-Error "Unknown playlist - $Playlist" ;
        return ;
    } # if-E
    if ($Shuffle) {
        if (!$ply.Shuffle) {
            $ply.Shuffle = $true ;
        } # if-E
    } # if-E
    $ply.PlayFirstTrack() ;
    [System.Runtime.InteropServices.Marshal]::ReleaseComObject([System.__ComObject]$iTunes) > $null ;
    [GC]::Collect() ;
}

#*------^ start-ItunesPlaylist.ps1 ^------


#*------v stop-browsers.ps1 v------
Function stop-browsers {

    <# 
    .SYNOPSIS
    stop-browsers - Cycle common browser proceses and close/kill them (as browsers frequently ignore close prompts from shell wo explicitly prompts, when trying to shutdown/reboot).
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     :	http://www.toddomation.com
    Twitter     :	@tostka / http://twitter.com/tostka
    CreatedDate : 2022-11-14
    FileName    : stop-browsers.ps1
    License     : MIT License
    Copyright   : (c) 2022 Todd Kadrie
    Github      : https://github.com/tostka/verb-Desktop
    Tags        : GoogleDrive
    AddedCredit : mklement0
    AddedWebsite:	https://stackoverflow.com/users/45375/mklement0
    AddedTwitter:	
    REVISIONS   :
    * 8:26 AM 11/14/2022 init
    .DESCRIPTION
    stop-browsers - Cycle common browser proceses and close/kill them (as browsers frequently ignore close prompts from shell wo explicitly prompts, when trying to shutdown/reboot).
    .PARAMETER Whatif
    Whatif no-exec test
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    System.Boolean
    .EXAMPLE
    PS> if(stop-browsers -verbose -whatif){'y'} else { 'n'} ; 
    Confirm Gdrv running, with verbose and whatif 
    .LINK
    https://github.com/tostka/verb-Desktop
    #>
    [CmdletBinding()]
    [Alias('sbn')]
    Param(
        [Parameter(HelpMessage="Whatif Flag  [-whatIf]")]
        [switch] $whatIf
    ) ; 
    BEGIN{
        $TargAppName="Firefox|Palemoon|Cyberfox|msEdge|Chrome" ;  # descriptive msg text
        # stop-process names to be killed
        $rgxPSTargetAppProc="^(firefox|palemoon|Cyberfox|chrome|msedge$)$" ;  
        # pskill/pslist select-sting pattern targets (as sysinternals don't emit objects, just text)
        $rgxPSETargetAppProc="(firefox|palemoon|Cyberfox|chrome|msedge)" ;  

    }
    PROCESS{
        w-h "Cycle common browser proceses and close/kill them (as browsers frequently ignore close prompts from shell)" ; 
        [array]$prcs = $prcE = @() ; 
        Try {
            write-verbose -verbose:$true "$(get-date -format 'yyyyMMdd-HHmmtt'): --PASS STARTED:$ScriptName --"
write-verbose -verbose:$true "killing $($TargAppName)"

            $prcs=get-process -ea silentlycontinue| ?{$_.name -match $rgxPSTargetAppProc} | sort name;
            if($prcs){
                $smsg = "TARGETS FOUND:`n$(($prcs | group Name | ft -a name,count |out-string).trim())`n" ; 
                write-host $smsg ; 
                if($prcs){ 
                    $prcs | stop-process -verbose -whatif:$($whatif) -erroraction silentlycontinue; 
                    start-sleep 2 ; 
                } else {
                    $smsg = "(no targets found)" ; 
                    write-host $smsg ; 
                } ; ; 
                # anything that survives above, pskill
                $prcE = pslist | select-string -pattern $rgxPSETargetAppProc ; 
                if($prcE){
                    # sysinternals has padded the output from 3 to 7 lines of baloney, including header line
                    #$prcE = $prcE | Select -Skip 7 |foreach-object{
                    # prefiltered, doesn't have headers, no need to skip 7
                    $prcE = $prcE | foreach-object{
                        $procinfo = $_ -split "\s+" ; 
                        [pscustomobject][ordered]@{
                            Name = $procInfo[0..($procInfo.Count -8)] -Join " "; 
                            Pid = $procInfo[-7].trim()  ; 
                            Pri = $procInfo[-6].trim() ; 
                            Thd = $procInfo[-5].trim()  ; 
                            Hnd = $procInfo[-4].trim() ; 
                            Priv = $procInfo[-3].trim()      ; 
                            "CPU Time" = $procInfo[-2].trim()   ; 
                            "Elapsed Time" = $procInfo[-1].trim()  ; 
                        }  ;                
                    } | sort name ; 
                    foreach($prc in $prcE){
                        write-verbose "pskill $($prc.pid) ($($prc.name))" ; 
                        if(!$whatif){
                        invoke-expression -command "pskill $($prc.pid)"
                        } else { 
                            write-host "(-whatif, skipping exec)" ; 
                        } ; 
                    } ; 
                    $smsg = "POST ZOMBIES RESULTS:`n$(($prcE = pslist | select-string -pattern $rgxPSETargetAppProc|out-string).trim())" ; 
                     write-host -foregroundcolor red $smsg ; 
                }
            }
        } Catch {
                $smsg = "ERROR!`n$($Error[0])"
                 write-warning $smsg ; throw $smsg ; 
                 #$false | write-output ; 
        } 
        Finally {
            
        } ;
    }  # PROC-E
    END{}
}

#*------^ stop-browsers.ps1 ^------


#*------v test-InstalledApplication.ps1 v------
Function test-InstalledApplication {
    <#
    .SYNOPSIS
    test-InstalledApplication.ps1 - Check registry for Installed status of specified application (checks x86 & x64 Uninstall hives, for substring matches on Name)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20210415-0913AM
    FileName    : test-InstalledApplication
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,Application,Install
    REVISIONS
    * 2:42 PM 2/21/2023 moved back to verb-desktop, vio is way too cluttered, and these are about system, not IO (with test-installedwindowsfeature)
    * 10:37 AM 11/11/2022 ren get-InstalledApplication -> test-InstalledApplication (better match for function, default is test -detailed triggers dump back); aliased orig name; also pulling in overlapping verb-desktop:check-ProgramInstalled(), aliased -Name with ported programNam ; CBH added expl output demo
    * 9:13 AM 4/15/2021 init vers
    .DESCRIPTION
    test-InstalledApplication.ps1 - Check registry for Installed status of specified application (checks x86 & x64 Uninstall hives, for substring matches on Name)
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns either System.Boolean (default) or System.Object (-detail)
    .EXAMPLE
    PS> if(test-InstalledApplication -name "powershell"){"yes"} else { "no"} ; 
    yes
    Default boolean test
    .EXAMPLE    
    PS> get-InstalledApplication -Name 'google drive' -detail
    DisplayName  DisplayVersion InstallLocation                                                      Publisher
    -----------  -------------- ---------------                                                      ---------
    Google Drive 63.0.5.0       C:\Program Files\Google\Drive File Stream\63.0.5.0\GoogleDriveFS.exe Google LLC
    Example returning detail (DisplayName and InstallLocation)
    .LINK
    https://github.com/tostka/verb-io
    #>
    [CmdletBinding()]
    [Alias('check-ProgramInstalled','get-InstalledApplication')]
    PARAM(
        [Parameter(Position=0,HelpMessage="Application Name substring[-Name Powershell]")]
        [Alias('programNam')]
        $Name,
        [Parameter(HelpMessage="Debugging Flag [-Return detailed object on match]")]
        [switch] $Detail
    ) ;
    $x86Hive = Get-ChildItem 'HKLM:Software\Microsoft\Windows\CurrentVersion\Uninstall' |
         % { Get-ItemProperty $_.PsPath } | ?{$_.displayname -like "*$($Name)*"} ;
    write-verbose "`$x86Hive:$([boolean]$x86Hive)" ; 
    if(Test-Path 'HKLM:Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall'){
        #$x64Hive = ((Get-ChildItem "HKLM:Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall") |
        #    Where-Object { $_.'Name' -like "*$($Name)*" } ).Length -gt 0;
        $x64Hive = Get-ChildItem 'HKLM:Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall' |
            % { Get-ItemProperty $_.PsPath } | ?{$_.displayname -like "*$($Name)*"} ;
         write-verbose "`$x64Hive:$([boolean]$x64Hive)" ; 
    }
    if(!$Detail){
        # boolean return:
        ($x86Hive -or $x64Hive) | write-output ; 
    } else { 
        $props = 'DisplayName','DisplayVersion','InstallLocation','Publisher' ;
        $x86Hive | Select $props | write-output ; 
        $x64Hive | Select $props | write-output ; 
    } ; 
}

#*------^ test-InstalledApplication.ps1 ^------


#*------v Test-InstalledWindowsFeature.ps1 v------
function Test-InstalledWindowsFeature {
	<#
    .SYNOPSIS
    Test-InstalledWindowsFeature - Check for Installed status of specified WindowsFeature
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20210415-0913AM
    FileName    : Test-InstalledWindowsFeature.ps1
    License     : MIT License
    Copyright   : (c) 2020 Todd Kadrie
    Github      : https://github.com/tostka/verb-XXX
    Tags        : Powershell,Application,Install
    REVISIONS
    * 10:37 AM 11/11/2022 init vers
    .DESCRIPTION
    Test-InstalledWindowsFeature - Check for Installed status of specified WindowsFeature
    .INPUTS
    None. Does not accepted piped input.
    .OUTPUTS
    Returns either System.Boolean
    .EXAMPLE    
    PS> Test-InstalledWindowsFeature -FeatureName 'RSAT-AD-Tools'
    Test for feature installation
    .LINK
    https://github.com/tostka/verb-io
    #>
	PARAM(
		[Parameter(Mandatory=$True,HelpMessage="WindowsFeature name to be Tested for installation[-FeatureName RSAT-AD-Tools")]
		$FeatureName
	) ; 
	[boolean]$(Get-WindowsFeature $FeatureName).Installed | write-output ; 
}

#*------^ Test-InstalledWindowsFeature.ps1 ^------


#*------v test-IsWindowsActivated.ps1 v------
function test-IsWindowsActivated {
    <#
    .SYNOPSIS
    test-IsWindowsActivated - Tests if local machine is properly License Activated.
    .NOTES
    Version     : 1.0.0.0
    Author: Todd Kadrie
    Website:	http://toddomation.com
    Twitter:	http://twitter.com/tostka
    CreatedDate : 2023-02-22
    FileName    : test-IsWindowsActivated
    License     : MIT License
    Copyright   : (c) 2023 Todd Kadrie
    AddedCredit : FoxDeploy
    AddedWebsite: https://stackoverflow.com/questions/29368414/need-script-to-find-server-activation-status
    AddedTwitter: 
    Github      : https://github.com/tostka/verb-desktop
    Tags        : Powershell,OS,License,Activiation
    REVISIONS
    * 12:06 PM 2/22/2023 init, from canned notes, and FoxDeploy's switchblock code for LicenseStatus values, added ISLicensed to the output. 
    .DESCRIPTION
    test-IsWindowsActivated - Tests if local machine is properly License Activated.
    .PARAMETER  User
    User security principal (defaults to current user)[-User `$SecPrinobj]
    .INPUTS
    Accepts piped input.
    .OUTPUTS
    System.Management.Automation.PSCustomObject
    Returns either System.Boolean (default) or System.Object (-detail)
    .EXAMPLE
    PS>  if((test-IsWindowsActivated).IsLicensed){
    PS>  	write-host "$($env:computername) is Activated/Licensed" ; 
    PS>  } else { 
    PS>  	write-warning "$($env:computername) is NOT Activated/Licensed!" ; 
    PS>  } ; 
    Test standard windows activation
    .LINK
    https://stackoverflow.com/questions/29368414/need-script-to-find-server-activation-status
    https://github.com/tostka/verb-desktop
    #>
    [CmdletBinding()]
    #[Alias('')]
    PARAM(
		[Parameter(Mandatory = $False,Position = 0,ValueFromPipeline = $True, HelpMessage = 'ComputerName to test[-ComputerName ServerName')]
		[string[]] $ComputerName=$env:COMPUTERNAME,
		[Parameter(Mandatory = $False,Position = 0,ValueFromPipeline = $True, HelpMessage = 'ComputerName to test[-ComputerName ServerName')]
		[string] $ProductFilter="Name like 'Windows%'" 
    ) ;
    BEGIN{
		if ($PSCmdlet.MyInvocation.ExpectingInput) {
			write-verbose "Data received from pipeline input: '$($InputObject)'" ; 
		} else {
			#write-verbose "Data received from parameter input: '$($InputObject)'" ; 
			write-verbose "(non-pipeline - param - input)" ; 
		} ; 
    }
    PROCESS{
		if(gcm get-ciminstance){
			$pltGCM=[ordered]@{
				ComputerName = $ComputerName ;ClassName = 'SoftwareLicensingProduct' ;Filter = $ProductFilter ; 
			} ; 
			$status = Get-CimInstance @pltGCM |
				?{ $_.PartialProductKey } | select Pscomputername,Name,
					@{Name='LicenseStatus';Exp={
						switch ($_.LicenseStatus) {
							0 {'Unlicensed'}
							1 {'licensed'}
							2 {'OOBGrace'}
							3 {'OOTGrace'}
							4 {'NonGenuineGrace'}
							5 {'Notification'}
							6 {'ExtendedGrace'}
							Default {'Undetected'}
						} 
				}},@{name="IsLicensed";expression={ if($_.LicenseStatus -eq 1){$true}else{$false}}} ; 
			$status | write-output ; 	
		} else { 
			$smsg = "MISSING DEPENDANT get-ciminstance CMD!" ; 
			if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN -Indent} 
			else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; 
		} ; 
	} ;
}

#*------^ test-IsWindowsActivated.ps1 ^------


#*------v Test-IsWindowsTerminal.ps1 v------
function Test-IsWindowsTerminal {
    <#
    .SYNOPSIS
    Test-IsWindowsTerminal - Tests if the current session is running inside Windows Terminal.
    .NOTES
    Version     : 1.0.0.0
    Author: Mike F. Robbins
    Website:	https://mikefrobbins.com/
    Twitter:	@mikefrobbins / https://twitter.com/mikefrobbins
    CreatedDate : 2023-02-22
    FileName    : Test-IsWindowsTerminal.ps1
    License     : (none asserted)
    Copyright   : (none asserted)
    AddedCredit : Todd Kadrie
    AddedWebsite: http://toddomation.com
    AddedTwitter: tostka / http://twitter.com/tostka
    Github      : https://github.com/tostka/verb-desktop
    Tags        : Powershell,WindowsTerminal,Session,Environment,Terminal,Host
    REVISIONS
    * 8:27 AM 6/27/2024 added CBH, flattened spaces & syntax
    5/16/24 MF's posted article. 
    .DESCRIPTION
    Test-IsWindowsTerminal - Tests if the current session is running inside Windows Terminal.
    .INPUTS
    Does not accept piped input.
    .OUTPUTS
    System.Boolean
    .EXAMPLE
    PS> if(Test-IsWindowsTerminal){
    PS>     write-host "$($env:computername) is Activated/Licensed" ; 
    PS> } else { 
    PS>     write-warning "$($env:computername) is NOT Activated/Licensed!" ; 
    PS> } ; 
    Test WinTerm session
    .LINK
    https://gist.github.com/mikefrobbins/2f3085a18f78330e37a5188444e79bc8
    https://mikefrobbins.com/2024/05/16/detecting-windows-terminal-with-powershell/
    https://github.com/tostka/verb-desktop
    #>
    [CmdletBinding()]
    #[Alias('')]
    PARAM ()
    <# variant approaches
#-=-=-=-=-=-=-=-=
# https://github.com/marvhen
# Checking the parent process doesn't work if WT is the Default Terminal Application, and you launch a console app from a graphical UI app.
function IsWindowsTerminal ($childProcess) {
    if (!$childProcess) {
        return $false
    } elseif ($childProcess.ProcessName -eq 'WindowsTerminal') {
        return $true
    } else {
        return IsWindowsTerminal -childProcess $childProcess.Parent
    }
}
return IsWindowsTerminal -childProcess (Get-Process -Id $PID)
#-=-=-=-=-=-=-=-=
#-=-=-=-=-=-=-=-=
# https://github.com/oising
function Test-WindowsTerminal { test-path env:WT_SESSION }
# or
if ($env:WT_SESSION) {
    # yes, windows terminal
} else {
    # nope
} ; 
#-=-=-=-=-=-=-=-=
#-=-=-=-=-=-=-=-=
# [TitoAldarondo](https://github.com/TitoAldarondo)
#So I too initially headed down the route of checking $Env:WT_SESSION, but quickly realized that this wouldn't work when SSHing to other hosts.
#-=-=-=-=-=-=-=-=
    #>
    if ($PSVersionTable.PSVersion.Major -le 5 -or $IsWindows -eq $true) {
        $currentPid = $PID
        # Loop through parent processes to check if Windows Terminal is in the hierarchy
        while ($currentPid) {
            try {$process = Get-CimInstance Win32_Process -Filter "ProcessId = $currentPid" -ErrorAction Stop -Verbose:$false}
            catch {return $false} ; 
            Write-Verbose -Message "ProcessName: $($process.Name), Id: $($process.ProcessId), ParentId: $($process.ParentProcessId)"
            if ($process.Name -eq 'WindowsTerminal.exe') {return $true} # if WinTerm
            else {$currentPid = $process.ParentProcessId}  ; # Move to the parent process
        }  ; # loop-E
        return $false  ;  # Return false if Windows Terminal is not found in the hierarchy
    } else {
        Write-Verbose -Message 'Exiting due to non-Windows environment' ; 
        return $false ; 
    } ; 
}

#*------^ Test-IsWindowsTerminal.ps1 ^------


#*------v Test-MyPackageTDO.ps1 v------
Function Test-MyPackageTDO{
            <#
            .SYNOPSIS
            Test-MyPackageTDO - Given a PackageID or pipe-delimted ('|') array of PackageIDs as used in the Registry under \Uninstall, \Products, or \Updates keys (e.g. {41D635FE-4F9D-47F7-8230-9B29D6D42D31} or KB3206632), this Tests-for/Confirms install status, and returns a string (variously the DisplayName HotfixID, or PackageName as stored on the matched key value) to the pipeline.
            .NOTES
            Version     : 0.0.1
            Author      : Todd Kadrie
            Website     : http://www.toddomation.com
            Twitter     : @tostka / http://twitter.com/tostka
            CreatedDate : 2025-08-15
            FileName    : Test-MyPackageTDO.ps1
            License     : (none asserted)
            Copyright   : (none asserted)
            Github      : https://github.com/tostka/verb-IO
            Tags        : Powershell,FileSystem,Backup,Development,Build,Staging
            AddedCredit :  Michel de Rooij / michel@eightwone.com
            AddedWebsite: https://eightwone.com / https://github.com/michelderooij/Install-Exchange15
            AddedTwitter: URL
            REVISIONS  
            * 9:10 AM 10/7/2025 added default pull via get-ciminstance, with fallback to Get-WMIObject; 
            * 11:47 AM 10/2/2025 port to C:\sc\powershell\PSScripts\build\Test-MyPackageTDO_func.ps1 - niche use, doesn't bear building into verb-io mod etc, but useful for patch verifications; also in xopBuildLibrary.psm1      
                substantially updated the CBH demos, citing specific pkg test examples that can be easily reused.
            * 11:34 AM 8/15/2025 ren: Test-MyPackage -> Test-MyPackageTDO and alias the orig name; add: CBH, fleshed out Parameter specs into formal well specified block. Added variety of working examples, for reuse adding future patches/packages to the mix.
            * 821's posted copy w/in install-Exchange15.ps1: Version 4.13, July 17th, 2025 821 install-Exchange15.ps1 func
            .DESCRIPTION
            Test-MyPackageTDO - Given a PackageID or pipe-delimted ('|') array of PackageIDs as used in the Registry under \Uninstall, \Products, or \Updates keys (e.g. {41D635FE-4F9D-47F7-8230-9B29D6D42D31} or KB3206632), this Tests-for/Confirms install status, and returns a string (variously the DisplayName HotfixID, or PackageName as stored on the matched key value) to the pipeline. 

            Usage relies on *knowing* the KBnnnnnnn number or GUID {nnDnnnFE-nFnD-nnFn-nnnn-nBnnDnDnnDnn} stored in the registry, that confirms patch/package install. 
            But with that data, this will check the stack of nested registry locations for the matching package install record.

            Self contained, has no dependancies.

            .INPUTS
            None. Does not accepted piped input.(.NET types, can add description)
            .OUTPUTS            
            System.String On a successful confirmation: Returns the DisplayName, HotfixID, or PackageName as stored on the matched key value
            .PARAMETER PackageID
            Microsoft KB number or {GUID} (e.g. {41D635FE-4F9D-47F7-8230-9B29D6D42D31} or KB3206632) for the update, as used in the Registry under \Uninstall, \Products, \Updates keys (used for install confirmation/detection) [-PackageID KB5057653]
            .EXAMPLE            
            PS> $PackageID = 'KB5049233' ; $PackageName = "Security Update For Exchange Server 2016 CU23 SU14 V2" ;             
            PS> if(Test-MyPackage -PackageID "KB3206632"){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Security Update For Exchange Server 2016 CU23 SU14 V2 package
            .EXAMPLE
            PS> $PackageID = "KB3206632"; $Package = "Cumulative Update for Windows Server 2016 for x64-based Systems" ; 
            PS> if(Test-MyPackage -PackageID "KB3206632"){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Cumulative Update for Windows Server 2016 kb3206632 OS patch 
            .EXAMPLE
            PS> $PackageID = "{9BCA2118-F753-4A1E-BCF3-5A820729965C}" ; $Package = "URL Rewrite Module 2.1"
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of URL Rewrite Module 2.1
            .EXAMPLE
            PS> $PackageID = "{41D635FE-4F9D-47F7-8230-9B29D6D42D31}" ; $Package = "Unified Communications Managed API 4.0 Runtime (Core)" ; 
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Unified Communications Managed API 4.0 Runtime (Core) (from the unpacked Exchange setup ISO, blank -OnlineURL)
            .EXAMPLE
            PS> $PackageID = "{41D635FE-4F9D-47F7-8230-9B29D6D42D31}" ; $Package = "Unified Communications Managed API 4.0 Runtime" ; 
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Unified Communications Managed API 4.0 Runtime
            .EXAMPLE
            PS> $PackageID = 'KB5049233' ; $Package = 'Security Update For Exchange Server 2019 CU14 SU3 V2' ;
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Security Update For Exchange Server 2019 CU14 SU3 V2
            .EXAMPLE
            PS> $PackageID = 'KB5049233' ; $Package = 'Security Update For Exchange Server 2019 CU13 SU7 V2'; 
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Security Update For Exchange Server 2019 CU13 SU7 V2
            .EXAMPLE
            PS> $PackageID = 'KB5049233' ; $Package = 'Security Update For Exchange Server 2016 CU23 SU14 V2';
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Security Update For Exchange Server 2016 CU23 SU14 V2
            .EXAMPLE
            PS> $PackageID = 'KB5057653' ; $Package = 'Hotfix Update for Exchange Server 2016 CU23 HU16'; 
            PS> if(Test-MyPackage -PackageID $PackageID){write-host "$($PackageID) : $($Package) is installed"} ; 
            Demo Test of Hotfix Update for Exchange Server 2016 CU23 HU16          
            .LINK
            https://github.com/michelderooij/Install-Exchange15
            .LINK
            https://github.com/tostka/verb-io
            .LINK
            https://github.com/tostka/powershellbb/
            #>
            [CmdletBinding()]
            [Alias('Test-MyPackage')]
            PARAM( 
                [Parameter(HelpMessage="Microsoft KB number or {GUID} (e.g. {41D635FE-4F9D-47F7-8230-9B29D6D42D31} or KB3206632) for the update, as used in the Registry under \Uninstall, \Products, \Updates keys (used for install confirmation/detection) [-PackageID KB5057653]")]
                    [String]$PackageID
            ) 
            $PackageSet= $PackageID.split('|')
            $PresenceKey= $null
            ForEach( $ID in $PackageSet) {
                $smsg = "Checking if package $ID is installed .."
                if(gcm Write-MyVerbose -ea 0){Write-MyVerbose $smsg } else {
                    if($VerbosePreference -eq 'Continue'){if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level VERBOSE } else{ write-verbose "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ; } ;
                } ;
                if (get-command get-ciminstance -ea 0) {
                    $PresenceKey = (get-ciminstance win32_quickfixengineering | Where-Object { $_.HotfixID -eq $ID }).HotfixID
                } else {
                    $PresenceKey= (Get-WmiObject win32_quickfixengineering | Where-Object { $_.HotfixID -eq $ID }).HotfixID
                }
                If( -not( $PresenceKey)) {
                    $PresenceKey= (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\$ID" -Name 'DisplayName' -ErrorAction SilentlyContinue).DisplayName
                    If(-not( $PresenceKey)) {
                        # Alternative (seen KB2803754, 2802063 register here)
                        $PresenceKey= (Get-ItemProperty -Path "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\$ID" -Name 'DisplayName' -ErrorAction SilentlyContinue).DisplayName
                        If( -not( $PresenceKey)){
                            # Alternative (eg Office2010FilterPack SP1)
                            $PresenceKey= (Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Installer\UserData\S-1-5-18\Products\$ID" -Name 'DisplayName' -ErrorAction SilentlyContinue).DisplayName
                            If( -not( $PresenceKey)){
                                # Check for installed Exchange IUs
                                if(get-variable -name State -ea 0){
                                    Switch( $State["MajorSetupVersion"]) {
                                        $EX2016_MAJOR {
                                            $IUPath= 'Exchange 2016'
                                        }
                                        default {
                                            $IUPath= 'Exchange 2019'
                                        }
                                    }
                                }elseif($MajorSetupVersion){
                                    Switch( $MajorSetupVersion) {
                                        $EX2016_MAJOR {
                                            $IUPath= 'Exchange 2016'
                                        }
                                        default {
                                            $IUPath= 'Exchange 2019'
                                        }
                                    }
                                }else{
                                    $smsg = "Missing Dep vari:Neither `$State['MajorSetupVersion'] -nor `$MajorSetupVersion FOUND!"
                                    if(gcm Write-MyWarning -ea 0){Write-MyWarning $smsg } else {
                                        if ($logging) { Write-Log -LogContent $smsg -Path $logfile -useHost -Level WARN} else{ write-WARNING "$((get-date).ToString('HH:mm:ss')):$($smsg)" } ;
                                    } ;
                                    break ; 
                                } ; 
                                $PresenceKey= (Get-ItemProperty -Path ('HKLM:\Software\Microsoft\Updates\{0}\{1}' -f $IUPath, $ID) -Name 'PackageName' -ErrorAction SilentlyContinue).PackageName
                            }
                        }
                    }
                }
            } # loop-E
            return $PresenceKey
        }

#*------^ Test-MyPackageTDO.ps1 ^------


#*------v update-Environment.ps1 v------
function update-Environment {
    <#
    .SYNOPSIS
    update-Environment - Refresh environment variables from the registry for powershell.exe. (wraps choco's refreshenv -> chocolateyProfile\Update-SessionEnvironment)
    .NOTES
    Version     : 1.0.0
    Author      : Todd Kadrie
    Website     : http://www.toddomation.com
    Twitter     : @tostka / http://twitter.com/tostka
    CreatedDate : 20250303-1230PM
    FileName    : update-Environment
    License     : MIT License
    Copyright   : (c) 2024 Todd Kadrie
    Github      : https://github.com/tostka/verb-dev
    Tags        : Powershell,ISE,development,debugging,backup
    REVISIONS
	* 12:30 PM 3/3/2025 init
    .DESCRIPTION
    update-Environment - Refresh environment variables from the registry for powershell.exe. (wraps choco's refreshenv -> chocolateyProfile\Update-SessionEnvironment)

	Simple easily recalled mnenomic verb-noun wrapper for chocolatey's native 'refreshenv' command (which is an alias of  chocolateyProfile\Update-SessionEnvironment)
	
    .EXAMPLE
    PS> update-Environment ;
    
		Refreshing environment variables from the registry for powershell.exe. Please wait...
		Finished		

    Update powershell session enivronment variables
    .LINK
    https://github.com/tostka/verb-desktop
    #>
    [CmdletBinding()]
    #[Alias('')]
    PARAM() ;
	#if(-not (get-module chocolateyprofile -list )){
	if(-not (get-command Update-SessionEnvironment) -AND -not (get-command choco.exe)){
		throw "Missing dependant module!" ; 
	} else {
		Update-SessionEnvironment -verbose; 
	}; 
}

#*------^ update-Environment.ps1 ^------


#*======^ END FUNCTIONS ^======

Export-ModuleMember -Function ....,...,..,~,Clean-Desktop,confirm-GoogleDriveRunning,c-winsallk,Define-MoveWindow,Disable-AutoLogonTDO,Disable-OpenFileSecurityWarningTDO,Disable-UACTDO,Enable-AutoLogonTDO,Enable-OpenFileSecurityWarningTDO,Enable-RunOnceTDO,Enable-UACTDO,get-localNicsTDO,Get-MyPackageTDO,get-OSFullVersionTDO,get-processTitled,Install-ChocoPkg,Install-ExePackage,Install-MsiPackage,Install-MyPackageTDO,Install-ServerRoles,invoke-Explore,Invoke-ExtractTDO,Invoke-ProcessTDO,invoke-speakwords,Move-Window,Move-WindowByWindowTitle,New-WallpaperStatusTDO,Report-URL,Reset-CurrentWallpaperTDO,restart-Shell,Set,Set-WallpaperTDO,show-TrayTip,start-ItunesPlaylist,stop-browsers,test-InstalledApplication,Test-InstalledWindowsFeature,test-IsWindowsActivated,Test-IsWindowsTerminal,Test-MyPackageTDO,update-Environment -Alias *



